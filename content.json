[{"title":"android FFmpeg3.4.2与SDL2.0.8播放音视频","date":"2018-04-19T06:56:08.000Z","path":"2018/04/19/ffmpeg-e8-a7-a3-e7-a0-81-e6-9c-ac-e5-9c-b0-e8-a7-86-e9-a2-91-e6-92-ad-e6-94-be-ef-bc-88-e9-85-8d-e5-90-88sdl2-ef-bc-89-e4-b8-80/","text":"一、FFmpeg编译 1、下载源码 https://github.com/FFmpeg/FFmpeg 2、编译环境 ubuntu16.04 64位 3.1、编译脚本 arm64.sh #!/bin/bashNDK=/home/shixq/android-ndk-r14bSYSROOT=$NDK/platforms/android-21/arch-arm64TOOLCHAIN=$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64 CPU=arm64-v8aPREFIX=$(pwd)/android/$CPUMP3LAME=/home/shixq/android-projects/ffmpeg/libmp3lameARCH=aarch64 ./configure \\–prefix=$PREFIX \\–enable-cross-compile \\–cross-prefix=$TOOLCHAIN/bin/aarch64-linux-android- \\–target-os=linux \\–arch=$ARCH \\–sysroot=$SYSROOT \\–extra-cflags=”-fPIE -pie -I$SYSROOT/usr/include -I$MP3LAME/include -march=armv8-a” \\–extra-ldflags=”-fPIE -pie -L$SYSROOT/usr/lib -L$MP3LAME/lib/$CPU” \\–disable-shared \\–enable-static \\–disable-doc \\–disable-ffplay \\–disable-decoders \\–disable-encoders \\–enable-libmp3lame \\–enable-encoder=libmp3lame \\–enable-decoder=flv \\–enable-decoder=mpeg4 \\–enable-decoder=h264 \\–enable-decoder=hevc \\–enable-decoder=yuv4 \\–enable-decoder=mp3 \\–enable-decoder=aac \\–enable-decoder=png \\–enable-decoder=mjpeg make cleanmakemake install 3.2、编译脚本arm.sh #!/bin/bashNDK=/home/shixq/android-ndk-r14bSYSROOT=$NDK/platforms/android-21/arch-armTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 CPU=armeabi-v7aPREFIX=$(pwd)/android/$CPUMP3LAME=/home/shixq/android-projects/ffmpeg/libmp3lameARCH=arm ./configure \\–prefix=$PREFIX \\–enable-cross-compile \\–cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\–target-os=linux \\–arch=$ARCH \\–sysroot=$SYSROOT \\–extra-cflags=”-fPIE -pie -I$SYSROOT/usr/include -I$MP3LAME/include -march=armv7-a” \\–extra-ldflags=”-fPIE -pie -L$SYSROOT/usr/lib -L$MP3LAME/lib/$CPU” \\–disable-shared \\–enable-static \\–disable-doc \\–disable-ffplay \\–disable-decoders \\–disable-encoders \\–enable-libmp3lame \\–enable-encoder=libmp3lame \\–enable-decoder=flv \\–enable-decoder=mpeg4 \\–enable-decoder=h264 \\–enable-decoder=hevc \\–enable-decoder=yuv4 \\–enable-decoder=mp3 \\–enable-decoder=aac \\–enable-decoder=png \\–enable-decoder=mjpeg make cleanmakemake install 3、将上边的编译脚本放到ffmpeg根目录执行，生成静态库文件和可执行文件。如果用ndk-r14b编译可能会遇到B0宏定义问题，解决办法修改ffmpeg源码中Bo为其他变量（例如b0）。 二、SDL 1、下载最新源码2.0.8。 2、Android Studio新建工程 将sdl根目录下的src文件夹放到sdl2中，可执行文件放到assets中 3、如何使用ffmpeg与sdl 移植ffmpeg官方示例ffplay，修改ffplay.c中realloc_texture方法 static int realloc_texture(SDL_Texture **texture, Uint32 new_format, int new_width, int new_height, SDL_BlendMode blendmode, int init_texture) { Uint32 format; int access, w, h; if (!*texture || SDL_QueryTexture(*texture, &amp;format, &amp;access, &amp;w, &amp;h) &lt; 0 || new_width != w || new_height != h || new_format != format) { void *pixels; int pitch; if (*texture) { SDL_DestroyTexture(*texture); } if (!(*texture = SDL_CreateTexture(renderer, new_format, SDL_TEXTUREACCESS_STREAMING, new_width, new_height))) return -1; if (SDL_SetTextureBlendMode(*texture, blendmode) &lt; 0) return -1; if (init_texture) { if (SDL_LockTexture(*texture, NULL, &amp;pixels, &amp;pitch) &lt; 0) return -1; memset(pixels, 0, pitch * new_height); SDL_UnlockTexture(*texture); } av_log(NULL, AV_LOG_VERBOSE, \"Created %dx%d texture with %s.\\n\", new_width, new_height, SDL_GetPixelFormatName(new_format)); } return 0; } 修改video_open方法 static int video_open(VideoState *is) { int w, h; SDL_GetWindowSize(window, &amp;screen_width, &amp;screen_height); if (screen_width) { w = screen_width; h = screen_height; } else { w = default_width; h = default_height; } if (!window_title) window_title = input_filename; SDL_SetWindowTitle(window, window_title); SDL_SetWindowSize(window, w, h); SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED); if (is_full_screen) SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN_DESKTOP); SDL_ShowWindow(window); is-&gt;width = w; is-&gt;height = h; return 0; } 枚举类型ShowMode移到VideoState外边 三、demo地址 [https://github.com/shixueqiang/ffplay-android](https://github.com/shixueqiang/ffplay-android)","tags":[]},{"title":"android pcre2使用及signal 11 (SIGSEGV) fault addr error","date":"2018-03-11T03:42:14.000Z","path":"2018/03/11/android-pcre2-e4-bd-bf-e7-94-a8-e5-8f-8asignal-11-sigsegv-fault-addr-error/","text":"pcre2源码ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre2-10.31.zip 我是直接用的aosp源码树下external/pcre模块的代码，然后先将pcre2编译成静态库，直接用ndk-build编译。 Android studio 新建支持c++的native工程，将pcrecpp代码导入到工程中，以下是配置文件： externalNativeBuild { // For ndk-build, instead use ndkBuild {} cmake { // Passes optional arguments to CMake. arguments &quot;-DANDROID_ARM_NEON=TRUE&quot;, &quot;-DANDROID_TOOLCHAIN=clang&quot;, &apos;-DANDROID_STL=gnustl_shared&apos; // Sets optional flags for the C compiler. cFlags &quot;-D_EXAMPLE_C_FLAG1&quot;, &quot;-D_EXAMPLE_C_FLAG2&quot; // Sets a flag to enable format macro constants for the C++ compiler. cppFlags &quot;-D__STDC_FORMAT_MACROS&quot; cppFlags &quot;-std=c++11&quot; } }ndk { // Specifies the ABI configurations of your native // libraries Gradle should build and package with your APK. abiFilters ‘armeabi-v7a’, ‘arm64-v8a’}需要注意的是gnustl需要使用动态库，我最初用的静态库在arm64位的手机上string assign就会报signal 11 (SIGSEGV) fault addr，原因可能是https://stackoverflow.com/questions/12590581/crash-on-stl-string-assignment-ndk pcrecpp的使用： JNIEXPORT jboolean Java_com_shixq_www_pcre2test_PhoneUtil_isPhoneMatch (JNIEnv env, jclass thiz, jstring phone, jstring regex) { char _phone = jstringToChar(env, phone); char* _regex = jstringToChar(env, regex); LOGE(“phone is %s,regex is %s”, _phone, _regex); pcrecpp::RE re(_regex); bool isMatch = re.FullMatch(_phone); return isMatch;} JNIEXPORT jstring Java_com_shixq_www_pcre2test_PhoneUtil_getPhonePrefix (JNIEnv env, jclass thiz, jstring phone, jstring regex) { char _phone = jstringToChar(env, phone); char* _regex = jstringToChar(env, regex); pcrecpp::RE re(_regex); string prefix; string minPhone; re.FullMatch(_phone, &amp;prefix, &amp;minPhone); LOGE(“phone prefix is %s”, prefix.c_str()); return env-&gt;NewStringUTF(prefix.c_str());} JNIEXPORT jstring Java_com_shixq_www_pcre2test_PhoneUtil_getMinPhone (JNIEnv env, jclass thiz, jstring phone, jstring regex) { char _phone = jstringToChar(env, phone); char* _regex = jstringToChar(env, regex); pcrecpp::RE re(_regex); string prefix; string minPhone; re.FullMatch(_phone, &amp;prefix, &amp;minPhone); LOGE(“phone un prefix is %s”, minPhone.c_str()); return env-&gt;NewStringUTF(minPhone.c_str());} 完整代码地址：https://github.com/shixueqiang/pcre2test&nbsp; &nbsp; &nbsp;","tags":[]},{"title":"android6.0系统通讯录源码","date":"2017-12-06T05:42:18.000Z","path":"2017/12/06/android6-0-e7-b3-bb-e7-bb-9f-e9-80-9a-e8-ae-af-e5-bd-95-e6-ba-90-e7-a0-81/","text":"“# Contacts6.0” android6.0原生系统通讯录，为了不与原生通讯录冲突，改了包名,代码来源：https://android.googlesource.com/platform/packages/apps 代码地址：https://github.com/shixueqiang/Contacts6.0","tags":[]},{"title":"DHT网络中计算torrent资源热度的一种方法","date":"2017-10-07T16:18:44.000Z","path":"2017/10/08/dht-e7-bd-91-e7-bb-9c-e4-b8-ad-e8-ae-a1-e7-ae-97torrent-e8-b5-84-e6-ba-90-e7-83-ad-e5-ba-a6-e7-9a-84-e4-b8-80-e7-a7-8d-e6-96-b9-e6-b3-95/","text":"DHT协议中有四种查询操作：主要负责通过UDP与外部节点交互，封装4种基本操作的请求以及响应。 ping：检查一个节点是否“存活” find_node：向一个节点发送查找节点的请求 get_peers：向一个节点发送查找资源的请求 announce_peer：向一个节点发送自己已经开始下载某个资源的通知 具体的协议可参考：http://www.bittorrent.org/beps/bep_0005.html 那么当收到一个announce_peer请求时，则表示资源被下载，热度可以+1，下面是我实现的mysql更新资源热度的存储过程： DELIMITER $$ USE torrent$$ DROP PROCEDURE IF EXISTS updatehots_pro$$ CREATE DEFINER=shixq@% PROCEDURE updatehots_pro(IN tId VARCHAR(64))BEGIN DECLARE t_error INTEGER DEFAULT 0; DECLARE t_id VARCHAR(64) DEFAULT NULL; DECLARE t_hots JSON DEFAULT NULL; DECLARE hotsLength INTEGER DEFAULT 0; DECLARE mTime DATETIME; DECLARE mHot INTEGER DEFAULT 0; DECLARE mNow VARCHAR(20); DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET t_error=1; START TRANSACTION; SELECT t.id,t.hots INTO t_id,t_hots FROM t_torrent t WHERE t.id = tId; IF t_id IS NOT NULL THEN SET mNow = DATE_FORMAT(NOW(),’%Y-%m-%d’); IF t_hots IS NOT NULL THEN SET mTime = STR_TO_DATE(REPLACE(JSON_EXTRACT(t_hots,’$[0].time’),’”‘,’’),’%Y-%m-%d’); IF STR_TO_DATE(mNow,’%Y-%m-%d’) = mTime THEN / 和第一个时间相同就在第一个基础上+1/ SET mHot = JSON_EXTRACT(t_hots,’$[0].hot’); UPDATE t_torrent t SET t.hot = mHot + 1, t.hots = JSON_REPLACE(t_hots,’$[0].hot’,mHot + 1) WHERE t.id = tId; ELSEIF STR_TO_DATE(mNow,’%Y-%m-%d’) &gt; mTime THEN / 在头部插入/ SET hotsLength = CEIL((LENGTH(t_hots) - LENGTH(REPLACE(t_hots,’},’,’’))) / 2 + 1); IF hotsLength = 14 THEN / 只保留最近两周热度/ SET t_hots = JSON_REMOVE(t_hots,’$[13]’); END IF; IF ‘OBJECT’ = JSON_TYPE(t_hots) THEN SET t_hots = JSON_ARRAY(JSON_OBJECT(“time”,mNow,”hot”,1),t_hots); ELSEIF ‘ARRAY’ = JSON_TYPE(t_hots) THEN SET t_hots = JSON_MERGE(JSON_OBJECT(“time”,mNow,”hot”,1),t_hots); END IF; UPDATE t_torrent t SET t.hot = 1, t.hots = t_hots WHERE t.id = tId; END IF; ELSE UPDATE t_torrent t SET t.hot = 1, t.hots = JSON_OBJECT(“time”,mNow,”hot”,1) WHERE t.id = tId; END IF; END IF; IF t_error = 1 THEN ROLLBACK; ELSE COMMIT; END IF; SELECT t_error,mNow,mTime; END$$ DELIMITER ;&nbsp;","tags":[]},{"title":"gyp ERR! stack You can pass the --python switch to point to Python >= v2.5.0 & < 3.0.0","date":"2017-09-26T16:02:58.000Z","path":"2017/09/27/gyp-err-stack-you-can-pass-the-python-switch-to-point-to-python-v2-5-0-3-0-0/","text":"npm install 的时候报了如下错误： gyp ERR! configure errorgyp ERR! stack Error: Python executable “C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\python.EXE” is v3.6.2, which is not supported by gyp.gyp ERR! stack You can pass the –python switch to point to Python &gt;= v2.5.0 &amp; &lt; 3.0.0.gyp ERR! stack at failPythonVersion (D:\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\lib\\configure.js:454:14)gyp ERR! stack at D:\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\lib\\configure.js:443:9gyp ERR! stack at ChildProcess.exithandler (child_process.js:189:7)gyp ERR! stack at emitTwo (events.js:106:13)gyp ERR! stack at ChildProcess.emit (events.js:191:7)gyp ERR! stack at maybeClose (internal/child_process.js:891:16)gyp ERR! stack at Socket. (internal/child_process.js:342:11)gyp ERR! stack at emitOne (events.js:96:13)gyp ERR! stack at Socket.emit (events.js:188:7)gyp ERR! stack at Pipe._handle.close [as _onclose] (net.js:497:12)gyp ERR! System Windows_NT 10.0.14393gyp ERR! command “D:\\nodejs\\node.exe” “D:\\nodejs\\node_modules\\npm\\node_modules\\node-gy 解决方法：安装不同版本python，然后使用时 npm install –(两个-)python=python2.7","tags":[]},{"title":"ant脚本使用multidex解决65536问题","date":"2017-08-06T09:46:31.000Z","path":"2017/08/06/ant-e8-84-9a-e6-9c-ac-e4-bd-bf-e7-94-a8multidex-e8-a7-a3-e5-86-b365536-e9-97-ae-e9-a2-98/","text":"现在的android项目应该大多都用gradle构建了吧，但是仍然有很多老项目使用的ant工具，这里并不推荐使用ant构建，因为最新的android sdk tools里边已经去掉了ant相关的lib包。不管gradle也好，ant也好，其实编译打包apk的过程基本都是一样的。 我遇到的这个项目，经历了两次方案的调整。 方案一： 最开始并没用dx的multidex参数，而是将所有的第三方jar包（应用启动时用的除外）打到从包中去，从包可以是多个，剩下的源码打到主包中，也就是分别调用dx打出dex包。 &lt;macrodef name=”dex-helper”&gt; &lt;element name=”external-libs” optional=”yes” /&gt; &lt;attribute name=”nolocals” default=”false” /&gt; &lt;sequential&gt; &lt;!– sets the primary input for dex. If a pre-dex task sets it to something else this has no effect –&gt; &lt;property name=”out.dex.input.absolute.dir” value=”${out.classes.absolute.dir}” /&gt; &amp;lt;!-- set the secondary dx input: the project (and library) jar files If a pre-dex task sets it to something else this has no effect --&amp;gt; &amp;lt;if&amp;gt; &amp;lt;condition&amp;gt; &amp;lt;isreference refid=&quot;out.dex.jar.input.ref&quot; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;else&amp;gt; &amp;lt;path id=&quot;out.dex.jar.input.ref&quot;&amp;gt; &amp;lt;path refid=&quot;project.all.jars.path&quot; /&amp;gt; &amp;lt;/path&amp;gt; &amp;lt;/else&amp;gt; &amp;lt;/if&amp;gt; &amp;lt;echo&amp;gt;Converting external libraries into ${assets}/${dex}...&amp;lt;/echo&amp;gt; &amp;lt;delete file=&quot;${asset.absolute.dir}\\plug.jar&quot;/&amp;gt; &amp;lt;delete file=&quot;${asset.absolute.dir}\\plug2.jar&quot;/&amp;gt; &amp;lt;if condition=&quot;${proguard.enabled}&quot;&amp;gt; &amp;lt;then&amp;gt; &amp;lt;separete inputjar=&quot;${out.dex.input.absolute.dir}&quot; mapping=&quot;${obfuscate.absolute.dir}/mapping.txt&quot; alljarpath=&quot;project.all.jars.path&quot; plugjarconfig=&quot;${plug.jar.config}&quot; plugjarconfig2=&quot;${plug.jar.config2}&quot; plugjarpath=&quot;project.plug.path&quot; plugjarpath2=&quot;project.plug.path2&quot; projectjarpath=&quot;project.core.path&quot;/&amp;gt; &amp;lt;path id=&quot;project.dex.core.path&quot;&amp;gt; &amp;lt;path refid=&quot;project.core.path&quot; /&amp;gt; &amp;lt;/path&amp;gt; &amp;lt;/then&amp;gt; &amp;lt;else&amp;gt; &amp;lt;filterlib &lt;/span&gt;&lt;/pre&gt; alljarpath=”project.all.jars.path” plugjarconfig=”${plug.jar.config}” plugjarconfig2=”${plug.jar.config2}” plugjarpath=”project.plug.path” plugjarpath2=”project.plug.path2” projectjarpath=”project.core.path”/&gt; &lt;path id=”project.dex.core.path”&gt; &lt;path path=”${out.dex.input.absolute.dir}”/&gt; &lt;path refid=”project.core.path” /&gt; &lt;/path&gt; &lt;/else&gt; &lt;/if&gt; &amp;lt;dex executable=&quot;${dx}&quot; output=&quot;${asset.absolute.dir}\\plug.jar&quot; dexedlibs=&quot;${out.dexed.absolute.dir}&quot; nolocals=&quot;@{nolocals}&quot; forceJumbo=&quot;${dex.force.jumbo}&quot; disableDexMerger=&quot;${dex.disable.merger}&quot; verbose=&quot;${verbose}&quot;&amp;gt; &amp;lt;path refid=&quot;project.plug.path&quot; /&amp;gt; &amp;lt;/dex&amp;gt; &amp;lt;dex executable=&quot;${dx}&quot; output=&quot;${asset.absolute.dir}\\plug2.jar&quot; dexedlibs=&quot;${out.dexed.absolute.dir}&quot; nolocals=&quot;@{nolocals}&quot; forceJumbo=&quot;${dex.force.jumbo}&quot; disableDexMerger=&quot;${dex.disable.merger}&quot; verbose=&quot;${verbose}&quot;&amp;gt; &amp;lt;path refid=&quot;project.plug.path2&quot; /&amp;gt; &amp;lt;/dex&amp;gt; &amp;lt;delete file=&quot;${asset.absolute.dir}\\plug.jar.d&quot;/&amp;gt; &amp;lt;delete file=&quot;${asset.absolute.dir}\\plug2.jar.d&quot;/&amp;gt; &amp;lt;checksum file=&quot;${asset.absolute.dir}\\plug.jar&quot; forceOverwrite=&quot;yes&quot;/&amp;gt; &amp;lt;checksum file=&quot;${asset.absolute.dir}\\plug2.jar&quot; forceOverwrite=&quot;yes&quot;/&amp;gt; &amp;lt;dex executable=&quot;${dx}&quot; output=&quot;${intermediate.dex.file}&quot; dexedlibs=&quot;${out.dexed.absolute.dir}&quot; nolocals=&quot;@{nolocals}&quot; forceJumbo=&quot;${dex.force.jumbo}&quot; disableDexMerger=&quot;${dex.disable.merger}&quot; verbose=&quot;${verbose}&quot;&amp;gt; &amp;lt;path refid=&quot;project.dex.core.path&quot; /&amp;gt; &amp;lt;external-libs /&amp;gt; &amp;lt;/dex&amp;gt; &amp;lt;/sequential&amp;gt; &amp;lt;/macrodef&amp;gt;&lt;/span&gt;&lt;/pre&gt; 其中separete和filterlib是两个自定义的task，作用都是从project.all.jars.path中过滤出事先定义好的第三方jar包的path，区别是separete是在代码经过混淆后执行，将混淆后的代码生成plug.jar，可以看到调用了三次dex。 代码中加载从包的方法： PathClassLoader pathClassLoader = (PathClassLoader) app.getClassLoader(); DexClassLoader dexClassLoader = new DexClassLoader(libPath, app.getDir(“dex”, 0).getAbsolutePath(), libPath, app.getClassLoader()); InjectResult result = null; try { Object dexElements = combineArray(getDexElements(getPathList(pathClassLoader)), getDexElements(getPathList(dexClassLoader))); Object pathList = getPathList(pathClassLoader); setField(pathList, pathList.getClass(), “dexElements”, dexElements); } catch (IllegalArgumentException e) { result = makeInjectResult(false, e); e.printStackTrace(); }DexClassLoader加载从包dex，然后将pathClassLoader与dexClassLoader中的DexPathList的dexElements属性值合并，再放到pathClassLoader中的DexPathList中。最开始方案一是满足需求的，但随着主包越来越大，终于还是65536了，这种只分出去第三方jar包的做法还是不太灵活，于是有了方案二。 方案二： 使用dx的multidex参数，指定maindexlist清单文件，在这个清单文件中的类会打到主包中，清单文件的生成可以使用build-tools下的mainDexClasses脚本生成。 &nbsp; &lt;macrodef name=”dex-helper” &gt; &lt;element name=”external-libs” optional=”yes” /&gt; &lt;attribute name=”nolocals” default=”false” /&gt; &lt;sequential&gt; &lt;!– sets the primary input for dex. If a pre-dex task sets it to something else this has no effect –&gt; &lt;property name=”out.dex.input.absolute.dir” value=”${out.classes.absolute.dir}” /&gt; &lt;if&gt; &lt;condition&gt; &lt;isreference refid=”out.dex.jar.input.ref” /&gt; &lt;/condition&gt; &lt;else&gt; &lt;path id=”out.dex.jar.input.ref”&gt; &lt;path refid=”project.all.jars.path” /&gt; &lt;/path&gt; &lt;/else&gt; &lt;/if&gt; &lt;echo message=”start dx ${maindexlist.dir}”/&gt; &lt;multidex executable=”${dx}” output=”${out.dir}” dexedlibs=”${out.dexed.absolute.dir}” nolocals=”@{nolocals}” forceJumbo=”${dex.force.jumbo}” disableDexMerger=”${dex.disable.merger}” multidex=”true” mainDexList=”${maindexlist.dir}” verbose=”${verbose}”&gt; &lt;path path=”${out.dex.input.absolute.dir}”/&gt; &lt;path refid=”out.dex.jar.input.ref” /&gt; &lt;external-libs /&gt; &lt;/multidex&gt; &lt;/sequential&gt; &lt;/macrodef&gt; &lt;target name=”-maindexlist” depends=”-set-release-mode, -compile, -post-compile, -obfuscate”&gt; &lt;property name=”out.dex.input.absolute.dir” value=”${out.classes.absolute.dir}” /&gt; &amp;lt;!-- set the secondary dx input: the project (and library) jar files If a pre-dex task sets it to something else this has no effect --&amp;gt; &amp;lt;if&amp;gt; &amp;lt;condition&amp;gt; &amp;lt;isreference refid=&quot;out.dex.jar.input.ref&quot; /&amp;gt; &amp;lt;/condition&amp;gt; &amp;lt;else&amp;gt; &amp;lt;path id=&quot;out.dex.jar.input.ref&quot;&amp;gt; &amp;lt;path refid=&quot;project.all.jars.path&quot; /&amp;gt; &amp;lt;/path&amp;gt; &amp;lt;/else&amp;gt; &amp;lt;/if&amp;gt; &amp;lt;maindexlist output=&quot;build/maindexlist-proguard.txt&quot; mainDexList=&quot;build/maindexlist.txt&quot; mappingFile=&quot;${out.absolute.dir}/proguard/mapping.txt&quot; &amp;gt; &amp;lt;path path=&quot;${out.dex.input.absolute.dir}&quot;/&amp;gt; &amp;lt;path refid=&quot;out.dex.jar.input.ref&quot; /&amp;gt; &amp;lt;/maindexlist&amp;gt; &amp;lt;/target&amp;gt;&lt;/span&gt;&lt;/pre&gt; multidex和maindexlist也是两个自定义task，multidex其实就是调用的dx –dex –multi-dex –main-dex-list=maindexlist.txt –minimal-main-dex –output bin –input-list,maindexlist task的作用是生成混淆后的主包清单文件。应用启动时代码原理和方案一差不多，也可以直接使用官方的android-surpport-multidex.jar包","tags":[]},{"title":"go语言AES CFB加解密服务端与客户端互通","date":"2017-08-03T16:09:20.000Z","path":"2017/08/04/go-e8-af-ad-e8-a8-80aes-cfb-e5-8a-a0-e8-a7-a3-e5-af-86-e6-9c-8d-e5-8a-a1-e7-ab-af-e4-b8-8e-e5-ae-a2-e6-88-b7-e7-ab-af-e4-ba-92-e9-80-9a/","text":"package utils import ( “bytes” “crypto/aes” “crypto/cipher” “encoding/base64” “fmt” “log”) var commonIV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f} var key = “32位key” func AesEncrypt(content string) string { // 创建加密算法aes c, err := aes.NewCipher([]byte(key)) if err != nil { log.Fatalln(“Error: NewCipher(%d bytes) = %s”, len(key), err) } //加密字符串 cfb := cipher.NewCFBEncrypter(c, commonIV) ciphertext := make([]byte, len(content)) cfb.XORKeyStream(ciphertext, []byte(content)) fmt.Printf(&quot;%s=&amp;gt;%x\\n&quot;, content, ciphertext) ciphertext = Base64Encode(ciphertext) return string(ciphertext) } func AesDecrypt(content string) string { text := make([]byte, len(content)) var err error text, err = Base64Decode([]byte(content)) if err != nil { log.Fatalln(err) } // 创建加密算法aes c, err := aes.NewCipher([]byte(key)) if err != nil { log.Fatalln(“Error: NewCipher(%d bytes) = %s”, len(key), err) } // 解密字符串 decryptText := make([]byte, len(text)) cfbdec := cipher.NewCFBDecrypter(c, commonIV) cfbdec.XORKeyStream(decryptText, []byte(text)) fmt.Printf(“%x=&gt;%s\\n”, text, decryptText) return string(decryptText)}&nbsp; 客户端解密时不同语言容易出现问题，一种简单的处理办法就是对go代码交叉编译出android端和ios端的lib库，我们可以使用go mobile，https://github.com/golang/go/wiki/Mobile 获取： $ go get golang.org/x/mobile/cmd/gomobile $ gomobile init # it might take a few minutes 编译： $ gomobile bind -target=android golang.org/x/mobile/example/bind/hello 会生成一个aar&nbsp;","tags":[]},{"title":"android根据包名获取签名MD5信息","date":"2017-05-11T14:14:18.000Z","path":"2017/05/11/android-e6-a0-b9-e6-8d-ae-e5-8c-85-e5-90-8d-e8-8e-b7-e5-8f-96-e7-ad-be-e5-90-8dmd5-e4-bf-a1-e6-81-af/","text":"private Signature[] getRawSignature(Context paramContext, String paramString) { if ((paramString == null) || (paramString.length() == 0)) { errout(“getSignature, packageName is null”); return null; } PackageManager localPackageManager = paramContext.getPackageManager(); PackageInfo localPackageInfo; try { localPackageInfo = localPackageManager.getPackageInfo(paramString, PackageManager.GET_SIGNATURES); if (localPackageInfo == null) { errout(“info is null, packageName = “ + paramString); return null; } } catch (PackageManager.NameNotFoundException localNameNotFoundException) { errout(“NameNotFoundException”); return null; } return localPackageInfo.signatures; } private Signature[] getRawSignature(Context paramContext, String paramString) { if ((paramString == null) || (paramString.length() == 0)) { errout(“getSignature, packageName is null”); return null; } PackageManager localPackageManager = paramContext.getPackageManager(); PackageInfo localPackageInfo; try { localPackageInfo = localPackageManager.getPackageInfo(paramString, PackageManager.GET_SIGNATURES); if (localPackageInfo == null) { errout(“info is null, packageName = “ + paramString); return null; } } catch (PackageManager.NameNotFoundException localNameNotFoundException) { errout(“NameNotFoundException”); return null; } return localPackageInfo.signatures; }源码地址：GenSignature","tags":[]},{"title":"使用glide填过的各种坑","date":"2017-01-22T05:43:49.000Z","path":"2017/01/22/e4-bd-bf-e7-94-a8glide-e5-a1-ab-e8-bf-87-e7-9a-84-e5-90-84-e7-a7-8d-e5-9d-91/","text":"使用版本glide-3.7.0 坑一： 无法手动刷新缓存，只能改变key添加自定义签名，我是将头像版本号放到key中了，因为取头像是根据手机号取的，头像url路径并不会变，而且首次加载时并不能拿到版本号。 builder.signature(new StringSignature(etag)); 坑二： 从磁盘缓存加载头像时太慢，导致能看到由默认图变到头像的过程，给人感觉头像闪了一下，体验不好。因为glide的磁盘缓存加载逻辑放到了工作线程中，提高了滑动时的流畅度，但是也降低了加载速度，没想到好办法解决; 坑三： 服务器返回的是xml数据，需要解析完xml才能获取头像byte[],好在glide有现成的api builder.asBitmap().imageDecoder(decoder) public class XmlBitmapDecoder implements ResourceDecoder&lt;InputStream, Bitmap&gt; { private static final String ID = “XmlBitmapDecoder.com.chinamobile.rcs.contacts.glide”; private String id; private final BitmapPool bitmapPool; public XmlBitmapDecoder(BitmapPool bitmapPool) { this.bitmapPool = bitmapPool; } @Override public Resource&amp;lt;Bitmap&amp;gt; decode(InputStream is, int width, int height) throws IOException { AvatarModel avatarModel = Utils.stream2Avatar(is); byte[] datas = avatarModel.getData(); Bitmap bitmap = BitmapFactory.decodeByteArray(datas, 0, datas.length); return BitmapResource.obtain(bitmap,bitmapPool); } @Override public String getId() { if (this.id == null) { this.id = ID; } return this.id; } }坑四： 消息列表中因为有不同的消息类型，默认头像也不一样，glide占位图不设置时，会设置null，所以onLoadStarted方法里需要区分开； 坑五： token验证，切圆角图，这个相对容易实现 坑六： 某些场景需要跳过缓存强制从网络拉取，但是需要先用缓存的头像当占位图，这点上glide没有开放现成的api，实现方式有点迂回： DrawableTypeRequest&lt;MyGlideUrl&gt; builder = Glide.with(mContext).using(new StreamModelLoader&lt;MyGlideUrl&gt;() { @Override public DataFetcher&amp;lt;InputStream&amp;gt; getResourceFetcher(final MyGlideUrl model, int arg1, int arg2) { return new DataFetcher&amp;lt;InputStream&amp;gt;() { @Override public InputStream loadData(Priority priority) throws Exception { throw new IOException(); // do nothing } @Override public void cleanup() { } @Override public String getId() { return model.getCacheKey(); } @Override public void cancel() { } }; } }).load(glideUrl);&lt;/pre&gt; 重点是loadData里边不做任何事，正常情况下这里本该写从网络拉取头像获取输入流的逻辑。这样就能变相实现从缓存拿到bitmap。 坑七： 还是加载慢的问题，但是有时候从memory缓存里加载竟然也需要50，60ms，打开glide调试，发现从缓存加载只需要零点几毫秒，但是从我代码调用到真正发起请求竟然用了大部分时间，有人说是得到view宽高后才会发起请求，于是添加.override(w, h)，效果不明显。 已经决定自己实现一套头像加载逻辑了，用第三方的实在是不够灵活","tags":[]},{"title":"android将so打到jar包中并运行","date":"2016-09-13T06:57:07.000Z","path":"2016/09/13/android-e5-b0-86so-e6-89-93-e5-88-b0jar-e5-8c-85-e4-b8-ad-e5-b9-b6-e8-bf-90-e8-a1-8c/","text":"加载so有两种方法 System.load() 和System.loadLibrary(); 前者需传入库文件的绝对路径，后者只需传入库文件名。 首先我的jar包目录如下： Loader是加载类： static { try { InputStream is = null; if(isCPUInfo64()) { is = Loader.class.getResource(“arm64/libhellojni.so”).openStream(); }else { is = Loader.class.getResource(“arm32/libhellojni.so”).openStream(); } File tempFile = File.createTempFile(“hellojni”, “.so”); FileOutputStream fos = new FileOutputStream(tempFile); int i; byte[] buf = new byte[1024]; while ((i = is.read(buf)) != -1) { fos.write(buf, 0, i); } is.close(); fos.close(); System.load(tempFile.getAbsolutePath()); tempFile.deleteOnExit(); } catch (IOException e) { e.printStackTrace(); } }&nbsp; private static boolean isCPUInfo64() { File cpuInfo = new File(“/proc/cpuinfo”); if (cpuInfo != null &amp;&amp; cpuInfo.exists()) { InputStream inputStream = null; BufferedReader bufferedReader = null; try { inputStream = new FileInputStream(cpuInfo); bufferedReader = new BufferedReader(new InputStreamReader(inputStream), 512); String line = bufferedReader.readLine(); if (line != null &amp;&amp; line.length() &gt; 0 &amp;&amp; line.toLowerCase(Locale.US).contains(“arch64”)) { return true; } else { return false; } } catch (Throwable t) { Log.d(“isCPUInfo64”, “ error = “ + t.toString()); } finally { try { if (bufferedReader != null) { bufferedReader.close(); } if (inputStream != null) { inputStream.close(); } } catch (Exception e) { e.printStackTrace(); } } } return false; }&nbsp;","tags":[]},{"title":"idea failed to create a child event loop","date":"2016-09-13T06:56:35.000Z","path":"2016/09/13/idea-failed-to-create-a-child-event-loop/","text":"idea14 有时候编译出现错误 Error:Abnormal build process termination:13:15:08,830 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.groovy] at [jar:file:/D:/Program%20Files/IntelliJ%20IDEA%2014.0.2/plugins/gradle/lib/gradle.jar!/logback.groovy]13:15:08,831 |-ERROR in ch.qos.logback.classic.LoggerContext[default] - Groovy classes are not available on the class path. ABORTING INITIALIZATION.Build process started. Classpath: /D:/Program Files/IntelliJ IDEA 14.0.2/lib/jps-launcher.jar;D:/Program Files (x86)/java/jdk1.7/lib/tools.jar;/D:/Program Files/IntelliJ IDEA 14.0.2/lib/optimizedFileManager.jar;D:/Program Files/IntelliJ IDEA 14.0.2/lib/ecj-4.4.jarError connecting to 127.0.0.1:61174; reason: failed to create a child event loopjava.lang.IllegalStateException: failed to create a child event loop at io.netty.util.concurrent.MultithreadEventExecutorGroup.&lt;init&gt;(MultithreadEventExecutorGroup.java:81) at io.netty.channel.MultithreadEventLoopGroup.&lt;init&gt;(MultithreadEventLoopGroup.java:50) at io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(NioEventLoopGroup.java:72) at io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(NioEventLoopGroup.java:58) at org.jetbrains.jps.cmdline.BuildMain.main(BuildMain.java:97) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.jetbrains.jps.cmdline.Launcher.main(Launcher.java:58)Caused by: io.netty.channel.ChannelException: failed to open a new selector at io.netty.channel.nio.NioEventLoop.openSelector(NioEventLoop.java:127) at io.netty.channel.nio.NioEventLoop.&lt;init&gt;(NioEventLoop.java:119) at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:97) at io.netty.channel.nio.NioEventLoopGroup.newChild(NioEventLoopGroup.java:31) at io.netty.util.concurrent.MultithreadEventExecutorGroup.&lt;init&gt;(MultithreadEventExecutorGroup.java:77) … 9 moreCaused by: java.io.IOException: Unable to establish loopback connection一、检测杀毒和防火墙； 二、 检查ping www.baidu.com 是否是通的，如果不通 ping ip是否是通的，重置网络环境，打开cmd ，输入 netsh winsock reset，重置网络环境，一般可恢复正常，有次我的乌龟svn也出现连接不上服务器的问题，重置网络后正常，严重怀疑360修改了网络配置文件。。。","tags":[]},{"title":"QT解压缩zlib和quazip的使用","date":"2016-09-13T06:55:30.000Z","path":"2016/09/13/qt-e8-a7-a3-e5-8e-8b-e7-bc-a9zlib-e5-92-8cquazip-e7-9a-84-e4-bd-bf-e7-94-a8/","text":"首先我的开发环境是windows10，qtvs2015，vs2015。 一、zlib的编译 1、官网下载最新的zlib源码，最新的是1.2.8 2、用vs自带的命令行工具（编译32位的dll选x86，64位的选x64）进入到zlib根目录，执行 nmake -f win32/Makefile.msc ,在根目录下生成：zlib.lib(静态库) zdll.lib(动态库的导入库) zlib1.dll(动态库) 。必要的头文件有zlib.h和zconf.h。 二、quazip的编译 1、quazip是zlib的封装库，下载源码后用QT打开，编译需要依赖zlib库，右键项目添加库选外部库就好。我添加后在.pro文件末尾会生成下面配置,注意编译64位的quazip，使用的zlib也必须是64位的 win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../zlib64/ -lzdll else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../zlib64/ -lzdll else:unix: LIBS += -L$$PWD/../zlib64/ -lzdll INCLUDEPATH += $$PWD/../zlib64 DEPENDPATH += $$PWD/../zlib64&nbsp; INCLUDEPATH是头文件路径 2、右键项目构建会生成quazip.lib和quazip.dll，注意zlib和quazip的默认字符集都是ANSI，在调用的文件的字符集也必须是ANSI，否则编译不过,使用utf-8的话，都必须是utf-8. 三、使用 1、使用时同样需要添加外部库zlib和quazip，字符集需要和dll一样，下面是一段解压缩代码 bool extract(const QString&amp; in_file_path, const QString&amp; out_file_path){ QuaZip archive(in_file_path); if (!archive.open(QuaZip::mdUnzip)) return false; QString path = out_file_path; if (!path.endsWith(&quot;/&quot;) &amp;amp;&amp;amp; !out_file_path.endsWith(&quot;\\\\&quot;)) path += &quot;/&quot;; QDir dir(out_file_path); if (!dir.exists()) dir.mkpath(out_file_path); for( bool f = archive.goToFirstFile(); f; f = archive.goToNextFile() ) { QString filePath = archive.getCurrentFileName(); QuaZipFile zFile(archive.getZipName(), filePath); zFile.open(QIODevice::ReadOnly ); QByteArray ba = zFile.readAll(); zFile.close(); if (filePath.endsWith(&quot;/&quot;)) { dir.mkpath(filePath); } else { QFile dstFile(path + filePath); if (!dstFile.open(QIODevice::WriteOnly)) return false; dstFile.write(ba); dstFile.close(); } } return true; }2、构建运行，新版QT运行需要拷贝qtvs2015下的plugins下的platforms文件夹到debug或release里边运行，还需要zlib1.dll和quazip.dll放到生成的exe同级目录下。运行没反应的话检查防火墙和杀毒。","tags":[]},{"title":"apprtc(webrtc) 本地搭建服务器","date":"2016-09-13T06:53:44.000Z","path":"2016/09/13/apprtcwebrtc-e6-9c-ac-e5-9c-b0-e6-90-ad-e5-bb-ba-e6-9c-8d-e5-8a-a1-e5-99-a8/","text":"这两天测试了下webrtc的效果，不知道是不是手机比较渣，画面并不是很清晰，先来说说服务器的部署。部署环境ubuntu14.04 32位。 一、服务器组成 1、AppRTC 房间服务器 https://github.com/webrtc/apprtc 2、Collider 信令服务器 上边源码里自带 3、coTurn 穿透服务器 https://github.com/coturn/coturn 4、需要自己实现coTurn连接信息接口，主要返回用户名、密码和turn配置信息，通常叫做TURN REST API,不实现这个接口的话AppRTCDemo连不上服务器，浏览器访问的话可以正常访问。 二、AppRTC房间服务器 1、下载代码 2、安装依赖 sudo apt-get install nodejs sudo npm install -g npm sudo apt-get install nodejs-legacy sudo npm -g install grunt-cli 切换到源码目录 cd apprtc-master npm install sudo apt-get install python-webtest grunt build 编译之后会多出out目录 运行还依赖 Google App Engine SDK for Python 需翻墙 下载完后设置环境变量 sudo gedit /etc/profile export PATH=$PATH:/home/google_appengine source /etc/profile 3、修改配置文件 主要是src/app_engine目录下的apprtc.py和constants.py 首先是constants.py： 修改TURN_BASE_URL = ‘http://192.168.214.129:80&#39; 这个是上边提到的连接信息接口的地址 TURN_URL_TEMPLATE = ‘%s/turn.php?username=%s&amp;key=%s’ CEOD_KEY = 和coturn turnserver.conf static-auth-secret一致 WSS_INSTANCES = [{WSS_INSTANCE_HOST_KEY: ‘192.168.214.129:8089’,WSS_INSTANCE_NAME_KEY: ‘wsserver-std’,WSS_INSTANCE_ZONE_KEY: ‘us-central1-a’}, {WSS_INSTANCE_HOST_KEY: ‘192.168.214.129:8089’,WSS_INSTANCE_NAME_KEY: ‘wsserver-std-2’,WSS_INSTANCE_ZONE_KEY: ‘us-central1-f’}] apprtc.py: 修改get_wss_parameters(request) 下的 if wss_tls and wss_tls == ‘false’:wss_url = ‘ws://‘ + wss_host_port_pair + ‘/ws’wss_post_url = ‘http://‘ + wss_host_port_pairelse:wss_url = ‘ws://‘ + wss_host_port_pair + ‘/ws’wss_post_url = ‘http://‘ + wss_host_port_pair 主要是把原来的wss和https的scheme都改为ws和http，不要让客户端和浏览器去使用ssl连接，如果有第三 方根证书的签名机构颁发的证书就不需要这样了。 修改完后重新grunt build下。 4、启动 dev_appserver.py –host=0.0.0.0 ./out/app_engine 三、Collider信令服务器 1、安装依赖 sudo apt-get install golang-go 2、在home目下创建文件夹 mkdir -p ~/collider_root 并在collider_root目录下创建src目录 设置GOPATH环境变量 export GOPATH=~/collider_root 将apprtc/src/collider目录下的三个文件夹都拷贝到collider_root/src下 进入到collider_root/src,开始编译安装collider，准备好翻墙 go get collidermain go install collidermain 成功编译后会在collider_root目录下生成bin和pkg目录，执行文件在bin下。 3、运行 修改collider_root/src/collidermain/main.go填上自己ip地址 var roomSrv = flag.String(“room-server”, “http://192.168.214.129:8080/&quot;, “The origin of the room server”) 启动 ~/collider_root/bin/collidermain -port=8089 -tls=false 四、coTurn 打洞服务器 1、下载http://turnserver.open-sys.org/downloads/ 找个适合自己linux系统的，我这里是ubuntu32位所以选了turnserver-4.2.1.2-debian-wheezy-ubuntu-mint-x86-32bits.tar.gz 下载完后解压进入解压目录 cat INSTALL 查看安装须知 sudo apt-get install gdebi-core sudo gdebi coturn_4.2.2.2-1_i386.deb 2、编辑配置文件 sudo gedit /etc/turnserver.conf listening-device=eth0 listening-port=3478 relay-device=eth1 min-port=49152max-port=65535 Verbose fingerprint lt-cred-mech use-auth-secret static-auth-secret=填写自己的密钥可不修改 stale-nonce cert=/usr/local/etc/turn_server_cert.pem pkey=/usr/local/etc/turn_server_pkey.pem no-loopback-peers no-multicast-peers mobility no-cli 3、生成签名证书 sudo openssl req -x509 -newkey rsa:2048 -keyout/usr/local/etc/turn_server_pkey.pem -out /usr/local/etc/turn_server_cert.pem -days 99999 -nodes 4、启动 service coturn start 五、coTurn连接信息接口 TURN REST API 标准参考文档 返回json结果示例： {“username”:”1456904882:1231244”,”password”:”jAph7EHMLuPJuxLLC1uRiI3kvq4=”,”ttl”:86400,”uris”:[“turn:192.168.214.129:3478?transport=udp”,”turn:192.168.214.129:3478?transport=tcp”,”turn:192.168.214.129:3479?transport=udp”,”turn:192.168.214.129:3479?transport=tcp”]} 1、username字段需要以timestamp + “:” + username的形式输出 2、响应的 password 字段，需要以 HMAC-SHA1 算法计算得出，公式为：【base64_encode( hmac( key, username ) )】。此处的 key，为 coTurn 服务器配置中的 “static-auth-secret”值。以 key 作为 hmac 算法的密钥，turn-username 为被计算的内容，得出的 hmac 摘要后，经 base64 编码得到最终密码。 3、uris为后台配置好的，我这里写死 4、很简单的接口，用惯了java，这里我准备用php，写起来比java快 &lt;?php $request_username = $_GET[&quot;username&quot;]; if(empty($request_username)) { echo &quot;username == null&quot;; exit; } $request_key = $_GET[&quot;key&quot;]; $time_to_live = 600; $timestamp = time() + $time_to_live;//失效时间 $response_username = $timestamp.&quot;:&quot;.$_GET[&quot;username&quot;]; $response_key = $request_key; if(empty($response_key)) $response_key = &quot;密钥&quot;;//constants.py中CEOD_KEY $response_password = getSignature($response_username, $response_key); $jsonObj = new Response(); $jsonObj-&amp;gt;username = $response_username; $jsonObj-&amp;gt;password = $response_password; $jsonObj-&amp;gt;ttl = 86400; $jsonObj-&amp;gt;uris = array(&quot;turn:192.168.214.129:3478?transport=udp&quot;,&quot;turn:192.168.214.129:3478?transport=tcp&quot;,&quot;turn:192.168.214.129:3479?transport=udp&quot;,&quot;turn:192.168.214.129:3479?transport=tcp&quot;); echo json_encode($jsonObj); /** * 使用HMAC-SHA1算法生成签名值 * * @param $str 源串 * @param $key 密钥 * * @return 签名值 */ function getSignature($str, $key) { $signature = &quot;&quot;; if (function_exists(&apos;hash_hmac&apos;)) { $signature = base64_encode(hash_hmac(&quot;sha1&quot;, $str, $key, true)); } else { $blocksize = 64; $hashfunc = &apos;sha1&apos;; if (strlen($key) &amp;gt; $blocksize) { $key = pack(&apos;H*&apos;, $hashfunc($key)); } $key = str_pad($key, $blocksize, chr(0x00)); $ipad = str_repeat(chr(0x36), $blocksize); $opad = str_repeat(chr(0x5c), $blocksize); $hmac = pack( &apos;H*&apos;, $hashfunc( ($key ^ $opad) . pack( &apos;H*&apos;, $hashfunc( ($key ^ $ipad) . $str ) ) ) ); $signature = base64_encode($hmac); } return $signature; } class Response { public $username = &quot;&quot;; public $password = &quot;&quot;; public $ttl = &quot;&quot;; public $uris = array(&quot;&quot;); } ?&gt;5、拿nginx部署下，怎么部署自行百度 六、测试 部署成功后可在浏览器输入http://192.168.214.129:8080创建房间 appRTCDemo连接也改成http://192.168.214.129:8080即可 七、参考连接 http://www.mamicode.com/info-detail-513556.html http://www.jianshu.com/p/c55ecf5a3fcf http://www.bubuko.com/infodetail-938737.htmll 八、关于webrtc编译 我只编译了android的版本，公司网速慢死，找了个国内下好的代码，分享到网盘了http://pan.baidu.com/s/1kUyNE55 AppRTCDemo的工程源码连接:AppRTCDemo工程源码 运行截图： &nbsp;","tags":[]},{"title":"TeamTalk——ubuntu服务端部署","date":"2016-09-13T06:52:30.000Z","path":"2016/09/13/teamtalk-ubuntu-e6-9c-8d-e5-8a-a1-e7-ab-af-e9-83-a8-e7-bd-b2/","text":"这是第二次部署了，第一次在双系统Ubuntu上部署，这次准备在虚拟机上部署，所用版本Ubuntu 15.10 64位(14.04版本编译出很多问题，所以直接用最新版),这里要感谢蓝狐的教程http://www.bluefoxah.org/teamtalk/new_tt_deploy.html 一、准本工作 1、更新操作系统(非必须) sudo apt-get update 2、删除已安装的软件 mysql、nginx、php最好都用新版。2.1安装mysql mysql版本5.6以上 sudo apt-get autoremove –purge mysql-server-5.5 sudo apt-get autoremove –purge mysql-client-5.5 官网下载mysql5.6 安装： sudo dpkg -i mysql-common_5.6.27-1ubuntu14.04_i386.deb mysql-community-client_5.6.27-1ubuntu14.04_i386.deb mysql-community- server_5.6.27-1ubuntu14.04_i386.deb 提示缺少 libaio1，安装libaio1 sudo apt-get install libaio1; 重新安装成功 或者 sudo apt-get install mysql-server mysql-client libmysqlclient-dev 导入sql脚本，进入TeamTalk-master/auto_setup/mariadb/conf/ source /自己的目录/TeamTalk-master/auto_setup/mariadb/conf/ttopen.sql; 2.2 安装php sudo apt-get install php5-fpm; sudo apt-get install php5-mysql; 2.3 安装nginx 如果先前安装了Apache2 先卸载，卸载方法同上 官网下载最新为1.9.7，解压 ./configure –prefix=/usr/local/nginx 安装在/usr/local下 提示缺少依赖包pcre sudo apt-get install libpcre3 libpcre3.dev 重新configure提示缺少zlib sudo apt-get install zlib1g zlib1g.dev 安装依赖 ssl sudo apt-get install libssl-dev 重新configure，通过，编译安装nginx sudo make sudo make install 启动 sudo /usr/local/nginx/sbin/nginx 2.4安装redis 官网下载 3.0.5 sudo make sudo make install 启动 ./redis-server 为了省事我这里不写启动脚本了 2.5 安装PB protobuf-2.6.1(teamtalk server源码目录下有)，安装 ./configure –prefix=/usr/local/protobuf sudo make sudo make install 3编译源码 3.1准备工作进入 server/src目录 sudo sh make_log4cxx.sh 报错，手动安装log4cxx依赖apr，apr-util 官网下载http://apr.apache.org/download.cgi 安装apr ./configure –prefix=/usr/apr sudo make sudo make install 安转apr-util .`/configure--prefix=/usr/apr-util--with-apr=/usr/apr`sudo make sudo make install 重新 sudo sh make_log4cxx.sh 还报错打开 make_log4cxx.sh 在build_log4cxx（）里修改apr与apr-util路径为刚才的安装路径 重新 sudo sh make_log4cxx.sh，通过。 sudo sh make_hredis.sh 3.2 编译server sudo sh build_ubuntu.sh version 1.0.0 缺少uuid的话安装 sudo apt-get install uuid-dev 编译成功后会在server目录下生成im-server-1.0.0压缩包 4、部署 解压im-server-1.0.0 为了方便看日志将lib包下的log4cxx.properties复制到各个server目录下 设置临时环境变量 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:自己的路径/im-server-1.0.0/lib 各个server的配置文件按蓝狐的教程就行 4.1db_proxy_server server启动顺序会有一定影响所以先启动db_proxy_server 进入db_proxy_server ../daeml db_proxy_server 查看是否启动 ps -ef|grep server 发现没有启动成功，去看log日志提示无法链接到192.168.1.94的数据库上 检查mysql的配置文件my.cnf发现bind-address监听的是127.0.0.1修改成本机ip，重启mysql 我用的root用户，所以还得为root开启远程访问权限 登录mysql，执行 grant all on mysql.* to ‘root‘@’%’ identified by ‘你的root密码’; flush privileges;//提交修改 退出mysql使用本机ip访问mysql mysql -h 192.168.0.94 -u root -p 如果能访问说明设置成功 重新启动db_proxy_server成功 4.2route_server ../daeml route_server 4.3file_server ../daeml file_server 4.4msfs 进入msfs目录 拷贝msfs.conf.example一份，重命名为msfs.conf 打开msfs.conf修改BaseDir=自己的目录/files，主要存放小文件照片，表情等 ../daeml msfs 4.5login_server ../daeml login_server 4.6msg_server ../daeml msg_server 4.7http_msg_server ../daeml http_msg_server 4.8push_server ../daeml push_server 5.配置php服务器 下面是我的nginx服务器的配置，nginx.conf &nbsp; user www-data;worker_processes auto; error_log /自己的目录/logs/error.log crit; #error_log logs/error.log notice; #error_log logs/error.log info; pid /usr/local/nginx/logs/nginx.pid; worker_rlimit_nofile 51200;events { use epoll; worker_connections 51200; multi_accept on;} http { include mime.types; default_type application/octet-stream; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable “MSIE [1-6].“; server_tokens off; log_format access ‘$remote_addr - $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘ ‘“$http_user_agent” $http_x_forwarded_for’; server { listen 80; server_name 192.168.214.130; root /自己的目录/www/teamtalk; location ~ \\.php($|/){ root /自己的目录/www/teamtalk; index index.html index.htm index.php default.html default.htm default.php; fastcgi_pass unix:/var/run/php5-fpm.sock;//这里写自己php-fpm.conf 里listen的位置 fastcgi_index index.php; fastcgi_split_path_info ^(.+\\.php)(.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\\.(js|css)?$ { expires 12h; } if (!-e $request_filename) { rewrite ^/(.*)$ /index.php/$1 last; break; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} }&nbsp; 修改完后记得重启nginx。 编译部署完成，如果所有server都启动了还是不能发消息的话，重新启动所有server再试一遍。 编译好的文件http://download.csdn.net/detail/s569646547/9326617 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;","tags":[]},{"title":"Volley扩展——文件断点下载（支持下载进度）","date":"2016-09-13T06:52:01.000Z","path":"2016/09/13/volley-e6-89-a9-e5-b1-95-e6-96-87-e4-bb-b6-e6-96-ad-e7-82-b9-e4-b8-8b-e8-bd-bd-ef-bc-88-e6-94-af-e6-8c-81-e4-b8-8b-e8-bd-bd-e8-bf-9b-e5-ba-a6-ef-bc-89/","text":"volley同样不适合大文件的下载，只能自己扩展了，我这里参考了Netroid,有兴趣的可以去分析下,文件下载模仿了图片的加载方式，添加了两个类 分别是FileDownloadRequest和FileDownloader。断点续传是根据http头里的Range 和Content-Range实现. Range用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式： Range:(unit=first byte pos)-[last byte pos] Content-Range用于响应头，指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth] 例如： Range: bytes=0-801 一般下载整个文件是 0-，没有后边的801 Content-Range: bytes 2753525-41526127/41526128 斜杠后边的是文件总大小 关键代码： public Map&lt;String, String&gt; getHeaders() throws AuthFailureError { Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(“Range”, “bytes=” + mTemporaryFile.length() + “-“); return map; }&nbsp; public byte[] handleResponse(HttpResponse response, ResponseDelivery delivery) throws IOException, ServerError { // Content-Length might be negative when use HttpURLConnection because it default header Accept-Encoding is gzip, // we can force set the Accept-Encoding as identity in prepare() method to slove this problem but also disable gzip response. HttpEntity entity = response.getEntity(); long fileSize = entity.getContentLength(); if (fileSize &lt;= 0) { VolleyLog.d(“Response doesn’t present Content-Length!”); } long downloadedSize = mTemporaryFile.length(); boolean isSupportRange = HttpUtils.isSupportRange(response); if (isSupportRange) { fileSize += downloadedSize; // Verify the Content-Range Header, to ensure temporary file is part of the whole file. // Sometime, temporary file length add response content-length might greater than actual file length, // in this situation, we consider the temporary file is invalid, then throw an exception. String realRangeValue = HttpUtils.getHeader(response, &quot;Content-Range&quot;); Log.e(&quot;FileDownloadRequest&quot;,&quot;response header Content-Range:&quot; + realRangeValue); // response Content-Range may be null when &quot;Range=bytes=0-&quot; if (!TextUtils.isEmpty(realRangeValue)) { String assumeRangeValue = &quot;bytes &quot; + downloadedSize + &quot;-&quot; + (fileSize - 1); Log.e(&quot;FileDownloadRequest&quot;,&quot;assumeRangeValue:&quot; + assumeRangeValue); if (TextUtils.indexOf(realRangeValue, assumeRangeValue) == -1) { throw new IllegalStateException( &quot;The Content-Range Header is invalid Assume[&quot; + assumeRangeValue + &quot;] vs Real[&quot; + realRangeValue + &quot;], &quot; + &quot;please remove the temporary file [&quot; + mTemporaryFile + &quot;].&quot;); } } } // Compare the store file size(after download successes have) to server-side Content-Length. // temporary file will rename to store file after download success, so we compare the // Content-Length to ensure this request already download or not. if (fileSize &amp;gt; 0 &amp;amp;&amp;amp; mStoreFile.length() == fileSize) { // Rename the store file to temporary file, mock the download success. ^_^ mStoreFile.renameTo(mTemporaryFile); // Deliver download progress. delivery.postProgress(this, fileSize, fileSize); return null; } RandomAccessFile tmpFileRaf = new RandomAccessFile(mTemporaryFile, &quot;rw&quot;); // If server-side support range download, we seek to last point of the temporary file. if (isSupportRange) { tmpFileRaf.seek(downloadedSize); } else { // If not, truncate the temporary file then start download from beginning. tmpFileRaf.setLength(0); downloadedSize = 0; } try { InputStream in = entity.getContent(); // Determine the response gzip encoding, support for HttpClientStack download. if (HttpUtils.isGzipContent(response) &amp;amp;&amp;amp; !(in instanceof GZIPInputStream)) { in = new GZIPInputStream(in); } byte[] buffer = new byte[6 * 1024]; // 6K buffer int offset; while ((offset = in.read(buffer)) != -1) { tmpFileRaf.write(buffer, 0, offset); downloadedSize += offset; delivery.postProgress(this, fileSize, downloadedSize); if (isCanceled()) { delivery.postCancel(this); break; } } } finally { try { // Close the InputStream and release the resources by &quot;consuming the content&quot;. if (entity != null) entity.consumeContent(); } catch (Exception e) { // This can happen if there was an exception above that left the entity in // an invalid state. VolleyLog.v(&quot;Error occured when calling consumingContent&quot;); } tmpFileRaf.close(); } return null; }&lt;/pre&gt; demo连接：http://download.csdn.net/detail/s569646547/9098291","tags":[]},{"title":"Volley扩展——文件上传（支持进度条）","date":"2016-09-13T06:51:32.000Z","path":"2016/09/13/volley-e6-89-a9-e5-b1-95-e6-96-87-e4-bb-b6-e4-b8-8a-e4-bc-a0-ef-bc-88-e6-94-af-e6-8c-81-e8-bf-9b-e5-ba-a6-e6-9d-a1-ef-bc-89/","text":"volley是一个轻量级的开源网络通信框架，开源的好处就是可以自由定制自己需要的jar包。volley里网络通信时android2.3以上用的 HttpUrlConnection,2.3以下用的HttpClient，我做的改动只考虑了2.3以上，不支持2.3版本以下。 HttpUrlConnection默认传输数据是将数据全部写到内存中再发送到服务端，Volley就是采用默认的方式，这样在上传大文件时很容易就 out of memory，有一种解决办法是设置每次传输流的大小： 已知文件大小：connection .setFixedLengthStreamingMode（long l）; 不知道文件大小：connection.setChunkedStreamingMode(1024); //建议使用 android的文件上传一般都是模拟表单，也可以直接socket传，我这里是集成了表单上传，下面是关键类： public class MultipartRequest extends Request&lt;String&gt; { private final Listener&lt;String&gt; mListener; private Map&lt;String, String&gt; headerMap; private Map&lt;String, String&gt; mParams; private FormFile[] files; private String BOUNDARY = “———7dc05dba8f3e19”; public MultipartRequest(String url, Listener&amp;lt;String&amp;gt; listener, Map&amp;lt;String, String&amp;gt; params, FormFile[] files) { this(Method.POST, url, listener, params, files); } public MultipartRequest(int method, String url, Listener&amp;lt;String&amp;gt; listener, Map&amp;lt;String, String&amp;gt; params, FormFile[] files) { super(method, url, listener); mListener = listener; mParams = params; this.files = files; } @Override public Map&amp;lt;String, String&amp;gt; getHeaders() throws AuthFailureError { headerMap = new HashMap&amp;lt;String, String&amp;gt;(); headerMap.put(&quot;Charset&quot;, &quot;UTF-8&quot;); //Keep-Alive headerMap.put(&quot;Connection&quot;, &quot;Keep-Alive&quot;); headerMap.put(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + BOUNDARY); return headerMap; } @Override public byte[] getBody() throws AuthFailureError { //传参数 StringBuilder sb = new StringBuilder(); for (Map.Entry&amp;lt;String, String&amp;gt; entry : mParams.entrySet()) { // 构建表单字段内容 sb.append(&quot;--&quot;); sb.append(BOUNDARY); sb.append(&quot;\\r\\n&quot;); sb.append(&quot;Content-Disposition: form-data; name=\\&quot;&quot; + entry.getKey() + &quot;\\&quot;\\r\\n\\r\\n&quot;); sb.append(entry.getValue()); sb.append(&quot;\\r\\n&quot;); } return sb.toString().getBytes(); } @Override public void handRequest(OutputStream out) { DataOutputStream dos = (DataOutputStream) out; try { //发送文件数据 if (files != null) { for (FormFile file : files) { // 发送文件数据 StringBuilder split = new StringBuilder(); split.append(&quot;--&quot;); split.append(BOUNDARY); split.append(&quot;\\r\\n&quot;); split.append(&quot;Content-Disposition: form-data;name=\\&quot;&quot; + file.getParameterName() + &quot;\\&quot;;filename=\\&quot;&quot; + file.getFilname() + &quot;\\&quot;\\r\\n&quot;); split.append(&quot;Content-Type: &quot; + file.getContentType() + &quot;\\r\\n\\r\\n&quot;); dos.write(split.toString().getBytes()); if (file.getInStream() != null) { byte[] buffer = new byte[1024]; int len = -1; int count = 0; while ((len = file.getInStream().read(buffer)) != -1) { dos.write(buffer, 0, len); count += len; if (mListener != null) { mListener.onProgressChange(file.getFileSize(), count); } } count = 0; file.getInStream().close(); } else { dos.write(file.getData(), 0, file.getData().length); } dos.write(&quot;\\r\\n&quot;.getBytes()); } } dos.writeBytes(&quot;--&quot; + BOUNDARY + &quot;--\\r\\n&quot;); dos.flush(); } catch (IOException e) { mListener.onError(new VolleyError(e.toString())); try { dos.close(); } catch (IOException e1) { e1.printStackTrace(); } } } @Override protected Response&amp;lt;String&amp;gt; parseNetworkResponse(NetworkResponse response) { String parsed; try { parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); } catch (UnsupportedEncodingException e) { parsed = new String(response.data); } return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); } @Override protected void deliverResponse(String response) { mListener.onSuccess(response); } @Override public void deliverError(VolleyError error) { mListener.onError(error); } }附上demo连接：http://download.csdn.net/detail/s569646547/9098291","tags":[]},{"title":"android横向滑动选择的view","date":"2016-09-13T06:51:06.000Z","path":"2016/09/13/android-e6-a8-aa-e5-90-91-e6-bb-91-e5-8a-a8-e9-80-89-e6-8b-a9-e7-9a-84view/","text":"做文字编辑，从网上找来的。 HorizontalScrollSelectView： public boolean mAlwaysOverrideTouch = true; protected ListAdapter mAdapter; private int mLeftViewIndex = -1; private int mRightViewIndex = 0; protected int mCurrentX; protected int mNextX; private int mMaxX = Integer.MAX_VALUE; private int mDisplayOffset = 0; protected Scroller mScroller; private GestureDetector mGesture; private Queue&lt;View&gt; mRemovedViewQueue = new LinkedList&lt;View&gt;(); private OnItemSelectedListener mOnItemSelected; private OnItemClickListener mOnItemClicked; private OnItemLongClickListener mOnItemLongClicked; private OnScrollListener mScrollListener; /** * 选中item时图片 */ private Drawable mDrawable; private boolean mDataChanged = false; private Context context; private boolean scrollerFalg1 = false; private boolean scrollerFalg2 = false; private int position = 0x7f020000; public HorizontalScrollSelectView(Context context, AttributeSet attrs) { super(context, attrs); this.context = context; initView(); } private synchronized void initView() { mLeftViewIndex = -1; mRightViewIndex = 0; mDisplayOffset = 0; mCurrentX = 0; mNextX = 0; mMaxX = Integer.MAX_VALUE; mScroller = new Scroller(getContext()); mGesture = new GestureDetector(getContext(), mOnGesture); } public void setMScrollListener(OnScrollListener listener) { mScrollListener = listener; } @Override public void setOnItemSelectedListener(OnItemSelectedListener listener) { mOnItemSelected = listener; } @Override public void setOnItemClickListener(OnItemClickListener listener) { mOnItemClicked = listener; } @Override public void setOnItemLongClickListener(OnItemLongClickListener listener) { mOnItemLongClicked = listener; } /** * 设置选中状态时的图片 * * @param mDrawable */ public void setSelectBitmap(Drawable mDrawable) { this.mDrawable = mDrawable; } private DataSetObserver mDataObserver = new DataSetObserver() { @Override public void onChanged() { synchronized (HorizontalScrollSelectView.this) { mDataChanged = true; } invalidate(); requestLayout(); } @Override public void onInvalidated() { reset(); invalidate(); requestLayout(); } }; @Override public ListAdapter getAdapter() { return mAdapter; } @Override public View getSelectedView() { //TODO: implement return null; } @Override public void setAdapter(ListAdapter adapter) { if (mAdapter != null) { mAdapter.unregisterDataSetObserver(mDataObserver); } mAdapter = adapter; mAdapter.registerDataSetObserver(mDataObserver); reset(); } private synchronized void reset() { initView(); removeAllViewsInLayout(); requestLayout(); } @Override public void setSelection(int position) { //TODO: implement int positionX = position * this.getWidth(); int maxWidth = this.getChildCount() * this.getWidth(); if (positionX &amp;lt;= 0) { positionX = 0; } if (positionX &amp;gt; maxWidth) { positionX = maxWidth; } scrollTo(positionX); } private void addAndMeasureChild(final View child, int viewPos) { LayoutParams params = child.getLayoutParams(); if (params == null) { params = new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT); } addViewInLayout(child, viewPos, params, true); child.measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.AT_MOST)); } @SuppressLint(&quot;NewApi&quot;) @Override protected synchronized void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); if (mAdapter == null) { return; } if (mDataChanged) { int oldCurrentX = mCurrentX; initView(); removeAllViewsInLayout(); mNextX = oldCurrentX; mDataChanged = false; } if (mScroller.computeScrollOffset()) { int scrollx = mScroller.getCurrX(); mNextX = scrollx; } // if(mNextX &lt;= 0){// mNextX = 0;// mScroller.forceFinished(true);// }// if(mNextX &gt;= mMaxX) {// mNextX = mMaxX;// mScroller.forceFinished(true);// } int dx = mCurrentX - mNextX; removeNonVisibleItems(dx); fillList(dx); positionItems(dx); // Log.e(“onlayout”, “mLeftViewIndex”+(mLeftViewIndex+1)); mCurrentX = mNextX; if (!mScroller.isFinished()) { post(new Runnable() { @Override public void run() { requestLayout(); } }); } else { if (scrollerFalg1 || (!scrollerFalg1 &amp;amp;&amp;amp; scrollerFalg2)) { View chid = getChildAt(0); if (chid != null) { mDisplayOffset = 0; positionItems(0); if (mDrawable != null) { getChildAt(2).setBackground(mDrawable); } if (mScrollListener != null) { int position = (int) getChildAt(2).getTag(this.position); mScrollListener.onScrollSelectItem(this, position); } } } } } /** * 获取屏幕宽度 * * @param context * @return */ public static int getSecreenWidth(Context context) { DisplayMetrics dm = new DisplayMetrics(); dm = context.getResources().getDisplayMetrics(); int screenWidth = dm.widthPixels; return screenWidth / 5; } private void fillList(final int dx) { int edge = 0; View child = getChildAt(0); if (child != null) { edge = child.getLeft(); } fillListLeft(edge, dx); edge = 0; child = getChildAt(getChildCount() - 1); if (child != null) { edge = child.getRight(); } fillListRight(edge, dx); } private void fillListRight(int rightEdge, final int dx) { //&amp;amp;&amp;amp; mRightViewIndex &amp;lt; mAdapter.getCount() while (rightEdge + dx &amp;lt; getWidth()) { if (mRightViewIndex &amp;gt;= mAdapter.getCount()) { mRightViewIndex = 0; } View child = mAdapter.getView(mRightViewIndex, mRemovedViewQueue.poll(), this); child.setTag(position, mRightViewIndex); addAndMeasureChild(child, -1); rightEdge += child.getMeasuredWidth(); // if(mRightViewIndex == mAdapter.getCount()-1) {// mMaxX = mCurrentX + rightEdge - getWidth();// }//// if (mMaxX &lt; 0) {// mMaxX = 0;// } mRightViewIndex++; } } private void fillListLeft(int leftEdge, final int dx) { //&amp;amp;&amp;amp; mLeftViewIndex &amp;gt;= 0 while (leftEdge + dx &amp;gt; 0) { if (mLeftViewIndex &amp;lt;= -1) { mLeftViewIndex = mAdapter.getCount() - 1; } View child = mAdapter.getView(mLeftViewIndex, mRemovedViewQueue.poll(), this); child.setTag(position, mLeftViewIndex); addAndMeasureChild(child, 0); leftEdge -= child.getMeasuredWidth(); mLeftViewIndex--; mDisplayOffset -= child.getMeasuredWidth(); } } private void removeNonVisibleItems(final int dx) { View child = getChildAt(0); while (child != null &amp;amp;&amp;amp; child.getRight() + dx &amp;lt;= 0) { mDisplayOffset += child.getMeasuredWidth(); mRemovedViewQueue.offer(child); removeViewInLayout(child); mLeftViewIndex++; if (mLeftViewIndex &amp;gt;= mAdapter.getCount()) { mLeftViewIndex = 0; } child = getChildAt(0); } child = getChildAt(getChildCount() - 1); while (child != null &amp;amp;&amp;amp; child.getLeft() + dx &amp;gt;= getWidth()) { mRemovedViewQueue.offer(child); removeViewInLayout(child); mRightViewIndex--; if (mRightViewIndex &amp;lt;= -1) { mRightViewIndex = mAdapter.getCount() - 1; } child = getChildAt(getChildCount() - 1); } } private void positionItems(final int dx) { if (getChildCount() &amp;gt; 0) { mDisplayOffset += dx; int left = mDisplayOffset; for (int i = 0; i &amp;lt; getChildCount(); i++) { View child = getChildAt(i); getChildAt(2).setBackground(null); int childWidth = child.getMeasuredWidth(); child.layout(left, 0, left + childWidth, child.getMeasuredHeight()); left += childWidth + child.getPaddingRight(); } } } public synchronized void scrollTo(int x) { mScroller.startScroll(mNextX, 0, x - mNextX, 0); requestLayout(); } @Override public boolean dispatchTouchEvent(MotionEvent ev) { boolean handled = super.dispatchTouchEvent(ev); handled |= mGesture.onTouchEvent(ev); switch (ev.getAction()) { case MotionEvent.ACTION_UP: scrollerFalg2 = true; requestLayout(); break; default: break; } return handled; } protected boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { synchronized (HorizontalScrollSelectView.this) { //mNextX mScroller.fling(mNextX, 0, (int) -velocityX, 0, Integer.MIN_VALUE, mMaxX, 0, 0); } requestLayout(); scrollerFalg1 = true; return true; } protected boolean onDown(MotionEvent e) { mScroller.forceFinished(true); return true; } public interface OnScrollListener { /** * 互动过程中选中的item * * @param position */ public void onScrollSelectItem(ViewGroup viewGroup, int position); } private OnGestureListener mOnGesture = new GestureDetector.SimpleOnGestureListener() { @Override public boolean onDown(MotionEvent e) { return HorizontalScrollSelectView.this.onDown(e); } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { return HorizontalScrollSelectView.this.onFling(e1, e2, velocityX, velocityY); } @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { synchronized (HorizontalScrollSelectView.this) { mNextX += (int) distanceX; } requestLayout(); scrollerFalg1 = false; scrollerFalg2 = false; return true; } @Override public void onShowPress(MotionEvent e) { super.onShowPress(e); } @Override public boolean onSingleTapUp(MotionEvent e) { Log.e(&quot;onSingleTapUp&quot;, &quot;mLeftViewIndex&quot; + (mLeftViewIndex + 1)); // scrollerFalg=true; return super.onSingleTapUp(e); } @Override public boolean onSingleTapConfirmed(MotionEvent e) { for (int i = 0; i &amp;lt; getChildCount(); i++) { View child = getChildAt(i); if (isEventWithinView(e, child)) { if (mOnItemClicked != null) { mOnItemClicked.onItemClick(HorizontalScrollSelectView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i)); } if (mOnItemSelected != null) { mOnItemSelected.onItemSelected(HorizontalScrollSelectView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i)); } break; } } return true; } @Override public void onLongPress(MotionEvent e) { int childCount = getChildCount(); for (int i = 0; i &amp;lt; childCount; i++) { View child = getChildAt(i); if (isEventWithinView(e, child)) { if (mOnItemLongClicked != null) { mOnItemLongClicked.onItemLongClick(HorizontalScrollSelectView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i)); } break; } } } private boolean isEventWithinView(MotionEvent e, View child) { Rect viewRect = new Rect(); int[] childPosition = new int[2]; child.getLocationOnScreen(childPosition); int left = childPosition[0]; int right = left + child.getWidth(); int top = childPosition[1]; int bottom = top + child.getHeight(); viewRect.set(left, top, right, bottom); return viewRect.contains((int) e.getRawX(), (int) e.getRawY()); } };&amp;lt;/span&amp;gt;&lt;/pre&gt; demo截图： demo地址：http://download.csdn.net/detail/s569646547/9070919","tags":[]},{"title":"android应用proguard混淆打包","date":"2016-09-13T06:50:37.000Z","path":"2016/09/13/android-e5-ba-94-e7-94-a8proguard-e6-b7-b7-e6-b7-86-e6-89-93-e5-8c-85/","text":"android应用发布的时候一般需要对代码混淆打包，这里贴上我自己的proguard配置文件： -libraryjars libs/gson-2.2.4.jar #项目里用到的第三方jar包-libraryjars libs/httpmime-4.1.3.jar-libraryjars libs/ImageLoader.jar-libraryjars libs/libammsdk.jar-libraryjars libs/mta-sdk-1.6.2.jar-libraryjars libs/nineoldandroids-2.4.0.jar-libraryjars libs/open_sdk_r4889.jar-libraryjars libs/rebound-core.jar-libraryjars libs/universal-image-loader-1.9.3.jar-libraryjars libs/volley.jar-libraryjars libs/weibosdkcore.jar -optimizationpasses 5 # 指定代码的压缩级别-dontusemixedcaseclassnames # 是否使用大小写混合-ignorewarning # 忽略警告，避免打包时某些警告出现-dontskipnonpubliclibraryclasses #指定不去忽略非公共的库类-dontoptimize #不优化输入的类文件-verbose # 混淆时是否记录日志 -optimizations !code/simplification/arithmetic,!field/,!class/merging/ #混淆时采用的算法 -keep public class extends android.app.Activity # 保持哪些类不被混淆-keep public class extends android.app.Application-keep public class extends android.app.Service-keep public class extends android.content.BroadcastReceiver-keep public class extends android.content.ContentProvider-keep public class extends android.app.backup.BackupAgentHelper-keep public class extends android.preference.Preference-keep public class extends android.support.v4.-keep public class com.android.vending.licensing.ILicensingService-keep class com.sina.{;}-keep class com.google.gson.stream.** { ; }-keep class com.csm.model.* { ; } -dontwarn android.support.v4. # 缺省proguard 会检查每一个引用是否正确,但是第三方库里面往往有些不会用到的类,没有正确引用。如果不配置的话,系统就会报错-dontwarn android.annotation-dontwarn org.apache.commons.net.-dontwarn android.webkit.WebView-dontwarn com.umeng.-dontwarn com.tencent.weibo.sdk. -keepclasseswithmembernames class * { #保持本地方法不被混淆 native &lt;methods&gt;;} -keepclasseswithmembers class * { #保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 public &lt;init&gt;(android.content.Context, android.util.AttributeSet);} -keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);} -keepclassmembers class extends android.app.Activity { #保护指定类的成员 public void (android.view.View);} -keepclassmembers enum * { #保持枚举enum类不被混淆 public static [] values(); public static valueOf(java.lang.String);} -keep class implements android.os.Parcelable { #保护继承Parcelable的类 public static final android.os.Parcelable$Creator ;} -keepattributes Annotation #保护注解&lt;/span&gt;下边附一篇比较详细的讲解： &lt;span style=”font-size:18px;”&gt;-include {filename} 从给定的文件中读取配置参数-basedirectory {directoryname} 指定基础目录为以后相对的档案名称-injars {class_path} 指定要处理的应用程序jar,war,ear和目录-outjars {class_path} 指定处理完后要输出的jar,war,ear和目录的名称-libraryjars {classpath} 指定要处理的应用程序jar,war,ear和目录所需要的程序库文件-dontskipnonpubliclibraryclasses 指定不去忽略非公共的库类。-dontskipnonpubliclibraryclassmembers 指定不去忽略包可见的库类的成员。 保留选项-keep {Modifier} {class_specification} 保护指定的类文件和类的成员-keepclassmembers {modifier} {class_specification} 保护指定类的成员，如果此类受到保护他们会保护的更好-keepclasseswithmembers {class_specification} 保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。-keepnames {class_specification} 保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）-keepclassmembernames {class_specification} 保护指定的类的成员的名称（如果他们不会压缩步骤中删除）-keepclasseswithmembernames {class_specification} 保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）-printseeds {filename} 列出类和类的成员-keep选项的清单，标准输出到给定的文件 压缩-dontshrink 不压缩输入的类文件-printusage {filename}-whyareyoukeeping {class_specification} 优化-dontoptimize 不优化输入的类文件-assumenosideeffects {class_specification} 优化时假设指定的方法，没有任何副作用-allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员 混淆-dontobfuscate 不混淆输入的类文件-printmapping {filename}-applymapping {filename} 重用映射增加混淆-obfuscationdictionary {filename} 使用给定文件中的关键字作为要混淆方法的名称-overloadaggressively 混淆时应用侵入式重载-useuniqueclassmembernames 确定统一的混淆类的成员名称来增加混淆-flattenpackagehierarchy {package_name} 重新包装所有重命名的包并放在给定的单一包中-repackageclass {package_name} 重新包装所有重命名的类文件中放在给定的单一包中-dontusemixedcaseclassnames 是否使用大小写混写-keepattributes {attribute_name,…} 保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses.-renamesourcefileattribute {string} 设置源文件中给定的字符串常量&lt;/span&gt;&nbsp;","tags":[]},{"title":"android获取手机ip地址wifi状态与非wifi状态","date":"2016-09-13T06:50:08.000Z","path":"2016/09/13/android-e8-8e-b7-e5-8f-96-e6-89-8b-e6-9c-baip-e5-9c-b0-e5-9d-80wifi-e7-8a-b6-e6-80-81-e4-b8-8e-e9-9d-9ewifi-e7-8a-b6-e6-80-81/","text":"方法一（只适合wifi状态）： public static String getIp(Context contxext) { WifiManager wm = (WifiManager) contxext.getSystemService(Context.WIFI_SERVICE); // 检查Wifi状态 if (!wm.isWifiEnabled()) wm.setWifiEnabled(true); WifiInfo wi = wm.getConnectionInfo(); int ipAdd = wi.getIpAddress(); String ip = intToIp(ipAdd); return ip; } public static String intToIp(int i) { return (i &amp; 0xFF) + “.” + ((i &gt;&gt; 8) &amp; 0xFF) + “.” + ((i &gt;&gt; 16) &amp; 0xFF) + &quot;.&quot; + (i &amp;gt;&amp;gt; 24 &amp;amp; 0xFF); }&lt;/pre&gt; 方法二（通用ipv4地址）： private String getIp() { try { for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) { NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) { InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) { return inetAddress.getHostAddress(); } } } } catch (SocketException ex) { ex.printStackTrace(); } return null; }方法三（通用ipv4与ipv6） /** * Get IP address from first non-localhost interface * * @param useIPv4 true=return ipv4, false=return ipv6 * @return address or empty string */ public static String getIPAddress(boolean useIPv4) { try { List&amp;lt;NetworkInterface&amp;gt; interfaces = Collections.list(NetworkInterface.getNetworkInterfaces()); for (NetworkInterface intf : interfaces) { List&amp;lt;InetAddress&amp;gt; addrs = Collections.list(intf.getInetAddresses()); for (InetAddress addr : addrs) { if (!addr.isLoopbackAddress()) { String sAddr = addr.getHostAddress().toUpperCase(); boolean isIPv4 = InetAddressUtils.isIPv4Address(sAddr); if (useIPv4) { if (isIPv4) return sAddr; } else { if (!isIPv4) { int delim = sAddr.indexOf(&apos;%&apos;); // drop ip6 port suffix return delim &amp;lt; 0 ? sAddr : sAddr.substring(0, delim); } } } } } } catch (Exception ex) { } return &quot;&quot;; }&lt;/pre&gt; &nbsp;","tags":[]},{"title":"2015——VLC编译","date":"2016-09-13T06:48:48.000Z","path":"2016/09/13/2015-vlc-e7-bc-96-e8-af-91/","text":"一、工具准备 需要的工具最好都用最新版的。官方文档：https://wiki.videolan.org/AndroidCompile 1、编译系统：Ubuntu 32位，我这里用的是ubuntukylin-14.04.2-desktop-i386，安装在vmware虚拟机上，这里注意必须用32位linux系统，我最开始用的64位始终编译不成功。 2、sdk：官网下载最新的sdk，我这里用的是android-sdk-r24.3.3-linux.tar,解压后下载最新的build-tools，sdk5.0以上的（vlc使用了5.0以上才有的一些样式功能），以及最新的support library。 3、ndk：我这里用的是android-ndk-r10e-linux-86.bin。 4、jdk：我这里用的是jdk-8u51-linux-i586。二、环境准备1、安装必备的组件 sudo apt-get install automake ant autopoint cmake build-essential libtool \\ patch pkg-config protobuf-compiler ragel subversion unzip git 2、设置环境变量jdk： export JAVA_HOME=/home/shixq/tools/jdk1.8.0_51 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH sdk，ndk： export ANDROID_SDK=/home/shixq/tools/android-sdk-linux export ANDROID_NDK=/home/shixq/tools/android-ndk-r10e export PATH=$PATH:$ANDROID_SDK/platform-tools:$ANDROID_SDK/tools export ANDROID_ABI=armeabi-v7a ANDROID_ABI要根据所使用的android平台决定，可以是x86，mips，不写的话默认是armeabi-v7a。三、获取配置代码 git clone git://git.videolan.org/vlc-ports/android.git 会在当前目录生成一个android目录。 四、开始编译进入到android目录，执 行./compile.sh,脚本会自动下载vlc源码及编译所需的插件，网络良好的情况下下载还是比较快的，中间遇到的大部分问题都是因为被墙的原因导 致下载失败，如果你有vpn的话会顺利很多，否则的话只能手动去网上下了，总之就是哪个下失败，就手动下载下来放到对应目录下，然后接 着./compile.sh。这个过程可能重复很多次，要有耐心。中间还遇到个gettext版本问题，系统自带版本是0.18.3（使用 gettext –version查看版本）,编译配置文件所需版本要大于0.18.3，本来想手动升级下，从网上下载了0.19.3安装后没想到还是0.18.3，后 来根据这篇文章解决：http://stackoverflow.com/questions/30259182/build-vlc-for- android-project-failed-on-ubuntu-12-04。 &lt;span class=&quot;pun&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;vlc&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;439&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;AM_GNU_GETTEXT_VERSION&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;0.19&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;vlc&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;contrib&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;contrib&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;arm&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;linux&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;androideabi&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;gnutls&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;148&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;AM_GNU_GETTEXT_VERSION&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;0.18&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;pun&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;vlc&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;contrib&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;contrib&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;arm&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;linux&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;androideabi&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;libgpg&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;158&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;AM_GNU_GETTEXT_VERSION&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;0.19&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;])&lt;/span&gt; 就是手动将配置文件改成0.18.3。编译成功截图： 五、运行程序编译完后的apk文件在android/vlc-android/build/outputs下，程序运行需要的文件 libvlc 和vlc-android是主要的源代码，因为是用gradle构建的所以用eclipse的话，就比较悲催了，需要手动引入support下的 design和v7下的appcompat和cardview，还有个互相引用的问题，哎，所以还是用androd studio或者idea来运行程序吧。 附上资源连接：http://download.csdn.net/detail/s569646547/9049283","tags":[]},{"title":"Android的消息循环——线程间通信","date":"2016-09-13T06:47:26.000Z","path":"2016/09/13/android-e7-9a-84-e6-b6-88-e6-81-af-e5-be-aa-e7-8e-af-e7-ba-bf-e7-a8-8b-e9-97-b4-e9-80-9a-e4-bf-a1/","text":"Android的线程可分为UI线程和工作线程，UI线程默认开启消息循环，但是创建的工作线程默认是没有消息循环 和消息队列的，如果想让该 线程具有消息队列和消息循环，需要在线程中首先调用Looper.prepare()来创建消息队列，然后调用Looper.loop()进入消息循环。 如下例所示： class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); } }Android的Looper和HandlerLooper:每一个线程都可以产生一个Looper,用来管理线程的Message，Looper对象会建立一个MessgaeQueue数据结构来存放message。 Handler:与Looper沟通的对象，可以push消息或者runnable对象到MessgaeQueue，也可以从MessageQueue得到消息。 Activity是一个UI线程，运行于主线程中，Android系统在启动的时候会为Activity创建一个消息队列和消息循环（Looper）。详细实现请参考ActivityThread.java文件 Android应用程序进程在启动的时候，会在进程中加载ActivityThread类，并且执行这个类的main函数，应用程序的消息循环过程就是在这个main函数里面实现的 public static void main(String[] args) { SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Security.addProvider(new AndroidKeyStoreProvider()); Process.setArgV0(&quot;&amp;lt;pre-initialized&amp;gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } AsyncTask.init(); if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); }&lt;/pre&gt; 贴一篇别人分析的源码和自己的理解 //Looper类分析public class Looper { //static变量，判断是否打印调试信息。 private static final boolean DEBUG = false; private static final boolean localLOGV = DEBUG ? Config.LOGD : Config.LOGV; // sThreadLocal.get() will return null unless you&apos;ve called prepare(). //线程本地存储功能的封装，TLS，thread local storage,什么意思呢？因为存储要么在栈上，例如函数内定义的内部变量。要么在堆上，例如new或者malloc出来的东西//但是现在的系统比如Linux和windows都提供了线程本地存储空间，也就是这个存储空间是和线程相关的，一个线程内有一个内部存储空间，这样的话我把线程相关的东西就存储到//这个线程的TLS中，就不用放在堆上而进行同步操作了。//本人理解：线程局部变量，内部是类map存储，key为它本身，value是当前线程相关的变量副本 private static final ThreadLocal sThreadLocal = new ThreadLocal();//消息队列，MessageQueue，看名字就知道是个queue.. final MessageQueue mQueue; volatile boolean mRun;//和本looper相关的那个线程，初始化为null Thread mThread; private Printer mLogging = null;//static变量，代表一个UI Process（也可能是service吧，这里默认就是UI）的主线程 private static Looper mMainLooper = null; /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * {@link #loop()} after calling this method, and end it by calling * {@link #quit()}. */ //往TLS中设上这个Looper对象的，如果这个线程已经设过了ｌｏｏｐｅｒ的话就会报错//这说明，一个线程只能设一个looper public static final void prepare() { if (sThreadLocal.get() != null) { throw new RuntimeException(“Only one Looper may be created per thread”); } sThreadLocal.set(new Looper()); } /** Initialize the current thread as a looper, marking it as an application&apos;s main * looper. The main looper for your application is created by the Android environment, * so you should never need to call this function yourself. * {@link #prepare()} */ //由framework设置的UI程序的主消息循环，注意，这个主消息循环是不会主动退出的// public static final void prepareMainLooper() { prepare(); setMainLooper(myLooper());//判断主消息循环是否能退出….//通过quit函数向looper发出退出申请 if (Process.supportsProcesses()) { myLooper().mQueue.mQuitAllowed = false; } } private synchronized static void setMainLooper(Looper looper) { mMainLooper = looper; } /** Returns the application&apos;s main looper, which lives in the main thread of the application. */ public synchronized static final Looper getMainLooper() { return mMainLooper; } /** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ //消息循环，整个程序就在这里while了。//这个是static函数喔！ public static final void loop() { Looper me = myLooper();//从该线程中取出对应的looper对象 MessageQueue queue = me.mQueue;//取消息队列对象… while (true) { Message msg = queue.next(); // might block取消息队列中的一个待处理消息.. //if (!me.mRun) {//是否需要退出？mRun是个volatile变量，跨线程同步的，应该是有地方设置它。 // break; //} if (msg != null) { if (msg.target == null) { // No target is a magic identifier for the quit message. return; } if (me.mLogging!= null) me.mLogging.println( “&gt;&gt;&gt;&gt;&gt; Dispatching to “ + msg.target + “ “ + msg.callback + &quot;: &quot; + msg.what ); //msg.target目标handler msg.target.dispatchMessage(msg); if (me.mLogging!= null) me.mLogging.println( &quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); msg.recycle(); } } } /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ //返回和线程相关的looper public static final Looper myLooper() { return (Looper)sThreadLocal.get(); } /** * Control logging of messages as they are processed by this Looper. If * enabled, a log message will be written to &amp;lt;var&amp;gt;printer&amp;lt;/var&amp;gt; * at the beginning and ending of each message dispatch, identifying the * target Handler and message contents. * * @param printer A Printer object that will receive log messages, or * null to disable message logging. */ //设置调试输出对象，looper循环的时候会打印相关信息，用来调试用最好了。 public void setMessageLogging(Printer printer) { mLogging = printer; } /** * Return the {@link MessageQueue} object associated with the current * thread. This must be called from a thread running a Looper, or a * NullPointerException will be thrown. */ public static final MessageQueue myQueue() { return myLooper().mQueue; } //创建一个新的looper对象，//内部分配一个消息队列，设置mRun为true private Looper() { mQueue = new MessageQueue(); mRun = true; mThread = Thread.currentThread(); } public void quit() { Message msg = Message.obtain(); // NOTE: By enqueueing directly into the message queue, the // message is left with a null target. This is how we know it is // a quit message. mQueue.enqueueMessage(msg, 0); } /** * Return the Thread associated with this Looper. */ public Thread getThread() { return mThread; } //后面就简单了，打印，异常定义等。 public void dump(Printer pw, String prefix) { pw.println(prefix + this); pw.println(prefix + &quot;mRun=&quot; + mRun); pw.println(prefix + &quot;mThread=&quot; + mThread); pw.println(prefix + &quot;mQueue=&quot; + ((mQueue != null) ? mQueue : &quot;(null&quot;)); if (mQueue != null) { synchronized (mQueue) { Message msg = mQueue.mMessages; int n = 0; while (msg != null) { pw.println(prefix + &quot; Message &quot; + n + &quot;: &quot; + msg); n++; msg = msg.next; } pw.println(prefix + &quot;(Total messages: &quot; + n + &quot;)&quot;); } } } public String toString() { return &quot;Looper{&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot;}&quot;; } static class HandlerException extends Exception { HandlerException(Message message, Throwable cause) { super(createMessage(cause), cause); } static String createMessage(Throwable cause) { String causeMsg = cause.getMessage(); if (causeMsg == null) { causeMsg = cause.toString(); } return causeMsg; } } }&nbsp; class Handler{……….//handler默认构造函数public Handler() {//这个if是干嘛用的暂时还不明白，涉及到java的深层次的内容了应该 if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, “The following Handler class should be static or leaks might occur: “ + klass.getCanonicalName()); } }//获取本线程的looper对象//如果本线程还没有设置looper，这回抛异常 mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( “Can’t create handler inside thread that has not called Looper.prepare()”); }//无耻啊，直接把looper的queue和自己的queue搞成一个了//这样的话，我通过handler的封装机制加消息的话，就相当于直接加到了looper的消息队列中去了 mQueue = mLooper.mQueue; mCallback = null; }//还有好几种构造函数，一个是带callback的，一个是带looper的//由外部设置looper public Handler(Looper looper) { mLooper = looper; mQueue = looper.mQueue; mCallback = null; }// 带callback的，一个handler可以设置一个callback。如果有callback的话，//凡是发到通过这个handler发送的消息，都有callback处理，相当于一个总的集中处理//待会看dispatchMessage的时候再分析public Handler(Looper looper, Callback callback) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; }////通过handler发送消息//调用了内部的一个sendMessageDelayedpublic final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); }//FT，又封装了一层，这回是调用sendMessageAtTime了//因为延时时间是基于当前调用时间的，所以需要获得绝对时间传递给sendMessageAtTimepublic final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis &lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(Message msg, long uptimeMillis) { boolean sent = false; MessageQueue queue = mQueue; if (queue != null) {//把消息的target设置为自己，然后加入到消息队列中//对于队列这种数据结构来说，操作比较简单了 msg.target = this; sent = queue.enqueueMessage(msg, uptimeMillis); } else { RuntimeException e = new RuntimeException( this + “ sendMessageAtTime() called with no mQueue”); Log.w(“Looper”, e.getMessage(), e); } return sent; }//还记得looper中的那个消息循环处理吗//从消息队列中得到一个消息后，会调用它的target的dispatchMesage函数//message的target已经设置为handler了，所以//最后会转到handler的msg处理上来//这里有个处理流程的问题public void dispatchMessage(Message msg) {//如果msg本身设置了callback，则直接交给这个callback处理了 if (msg.callback != null) { handleCallback(msg); } else {//如果该handler的callback有的话，则交给这个callback处理了—相当于集中处理 if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } }//否则交给派生处理,基类默认处理是什么都不干 handleMessage(msg); } }……….}总结：android线程间通信可通过handler来解决，工作线程向UI线程发送消 息，handler.sendMessage(Message msg)或者post(Runnable obj)一个runnable对象，UI线程向工作线程发送消息，首先要手动开启工作线程的消息循环，handler必须在工作线程的run方法中创建， 然后由UI线程发送消息或runnable对象到工作线程。","tags":[]},{"title":"Android事件传递机制","date":"2016-09-13T06:43:59.000Z","path":"2016/09/13/44/","text":"最近在做一个图片，文字拖拽缩放的控件，所以研究了下android的事件传递机制，记录在此。 一、Activity——dispatchTouchEvent和onTouchEvent 先来看下Activity里的dispatchTouchEvent源码 public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); }getWindow().superDispatchTouchEvent(ev)，getWindow()返回的是一个PhoneWindow对象，执行了superDispatchTouchEvent(ev)方法，如果返回true表示事件被消费掉。 @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); }mDecor是一个DecorView对象，继承自FrameLayout，它是一个Activity的root view，通过super.dispatchTouchEvent会把事件分发给各个子view及Activity onCreate方法中setContentView里赋值的view。 二、ViewGroup——dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; }dispatchTouchEvent代码比较多，不全贴了，上边的代码是检查是否拦截事件的，onInterceptTouchEvent(ev)里代码很简单就返回了个false，disallowIntercept用来控制是否禁用拦截事件，可以通过requestDisallowInterceptTouchEvent方法改变值。如果事件没被拦截会执行下面的代码： final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final View[] children = mChildren; final boolean customOrder = isChildrenDrawingOrderEnabled(); for (int i = childrenCount - 1; i &amp;gt;= 0; i--) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = children[childIndex]; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); mLastTouchDownIndex = childIndex; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } } }&lt;/pre&gt; 遍历了所有子view，找到点击的view执行dispatchTransformedTouchEvent方法： if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; }&lt;/pre&gt; 可以看到child.dispatchTouchEvent(event)，所以ViewGroup的dispatchTouchEvent依次调用了子view的dispatchTouchEvent方法，当子view的dispatchTouchEvent方法返回true时事件到此结束，返回false时会去执行super.dispatchTouchEvent方法，也就是父类View的dispatchTouchEvent方法，下面介绍View的dispatchTouchEvent方法； 三、View——dispatchTouchEvent、onTouchEvent 先来看dispatchTouchEvent： public boolean dispatchTouchEvent(MotionEvent event) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) { return true; } if (onTouchEvent(event)) { return true; } } if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } return false; }&lt;/pre&gt; 判断了mOnTouchListener是否为空和它的返回值，如果不为空并且返回true，dispatchTouchEvent直接返回true，否则执行onTouchEvent(event)，onTouchEvent的默认返回值与CLICKABLE和LONG_CLICKABLE属性有关，例如button默认返回true，而textview默认返回false。如果onTouchEvent返回true及dispatchTouchEvent返回true时间传递结束，否则会执行父布局的onTouchEvent。 第一次写的有点乱","tags":[]},{"title":"Centos开机自启动redis","date":"2016-07-22T09:12:40.000Z","path":"2016/07/22/centos-e5-bc-80-e6-9c-ba-e8-87-aa-e5-90-af-e5-8a-a8redis/","text":"摘要Centos开机自启动redis 修改redis.conf，打开后台运行选项： # By default Redis does not run as a daemon. Use ‘yes’ if you need it. # Note that Redis will write a pid file in /var/run/redis.pid when daemonized. daemonize yes` 编写脚本，vim /etc/init.d/redis: &lt;span class=&quot;hljs-comment&quot;&gt;# chkconfig: 2345 10 90&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# description: Start and Stop redis&lt;/span&gt; PATH=/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/bin:/sbin:/usr/bin:/bin REDISPORT=6379 &lt;span class=&quot;hljs-comment&quot;&gt;#实际环境而定&lt;/span&gt; EXEC=/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/redis/src/redis-server &lt;span class=&quot;hljs-comment&quot;&gt;#实际环境而定&lt;/span&gt; REDIS_CLI=/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/redis/src/redis-cli &lt;span class=&quot;hljs-comment&quot;&gt;#实际环境而定&lt;/span&gt; PIDFILE=/var/run/redis.pid CONF=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/local/redis/redis.conf&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;#实际环境而定&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; start) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; [ &lt;span class=&quot;hljs-_&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$PIDFILE&lt;/span&gt; ] &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$PIDFILE&lt;/span&gt; exists, process is already running or crashed.&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Starting Redis server...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$EXEC&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$CONF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fi&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; [ &lt;span class=&quot;hljs-string&quot;&gt;&quot;$?&quot;&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0&quot;&lt;/span&gt; ] &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Redis is running...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fi&lt;/span&gt; ;; stop) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; [ ! &lt;span class=&quot;hljs-_&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$PIDFILE&lt;/span&gt; ] &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$PIDFILE&lt;/span&gt; exists, process is not running.&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; PID=$(cat &lt;span class=&quot;hljs-variable&quot;&gt;$PIDFILE&lt;/span&gt;) &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Stopping...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$REDIS_CLI&lt;/span&gt; -p &lt;span class=&quot;hljs-variable&quot;&gt;$REDISPORT&lt;/span&gt; SHUTDOWN &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; [ -x &lt;span class=&quot;hljs-variable&quot;&gt;$PIDFILE&lt;/span&gt; ] &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Waiting for Redis to shutdown...&quot;&lt;/span&gt; sleep 1 &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Redis stopped&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fi&lt;/span&gt; ;; restart|force-reload) &lt;span class=&quot;hljs-variable&quot;&gt;${0}&lt;/span&gt; stop &lt;span class=&quot;hljs-variable&quot;&gt;${0}&lt;/span&gt; start ;; *) &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Usage: /etc/init.d/redis {start|stop|restart|force-reload}&quot;&lt;/span&gt; &amp;gt;&amp;amp;2 &lt;span class=&quot;hljs-built_in&quot;&gt;exit&lt;/span&gt; 1 &lt;span class=&quot;hljs-keyword&quot;&gt;esac&lt;/span&gt; 执行权限： &lt;span class=&quot;hljs-attribute&quot;&gt;chmod&lt;/span&gt; +x /etc/init.d/redis 开机自启动： `# 尝试启动或停止redis service redis start service redis stop # 开启服务自启动 chkconfig redis on","tags":[]},{"title":"CentOS7安装配置redis-3.0.0","date":"2016-07-22T09:11:44.000Z","path":"2016/07/22/centos7-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeredis-3-0-0/","text":"# 清园沉没的Atlantis## CentOS7安装配置redis-3.0.0一.安装必要包yum install gcc二.linux下安装#下载wget http://download.redis.io/releases/redis-3.0.0.tar.gztar zxvf redis-3.0.0.tar.gzcd redis-3.0.0#如果不加参数,linux下会报错make MALLOC=libc 安装好之后,启动文件#启动redissrc/redis-server &amp;#关闭redissrc/redis-cli shutdown测试redis$ src/redis-cli127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; get foo“bar”$测试成功&nbsp;3.redis cluster集群搭建建立本机测试环境建立运行目录#建立redis运行目录mkdir -p redis-server/7000/#复制默认的配置文档cp redis-3.0.0/redis.conf redis-server/redis.default.conf#把编译好的server复制到运行目录cp redis-3.0.0/src/redis-server redis-server/7000/建立独立配置文件#在7000目录下建立redis的配置文档vim redis-server/7000/redis.conf文件内容#redis-server/7000/redis.confinclude /root/redis-server/redis.default.confpidfile /var/run/redis-7000.pidport 7000cluster-enabled yescluster-config-file redis-node-7000.confcluster-node-timeout 5000appendonly yes复制运行目录(模拟集群环境)#复制目录cp -R 7000/ 7001/cp -R 7000/ 7002/cp -R 7000/ 7003/cp -R 7000/ 7004/cp -R 7000/ 7005/修改相应配置文件的端口和文件名建立启动脚本 redis-server/redis-start.sh#!/bin/sh/root/redis-server/7000/redis-server /root/redis-server/7000/redis.conf &amp;/root/redis-server/7001/redis-server /root/redis-server/7001/redis.conf &amp;/root/redis-server/7002/redis-server /root/redis-server/7002/redis.conf &amp;/root/redis-server/7003/redis-server /root/redis-server/7003/redis.conf &amp;/root/redis-server/7004/redis-server /root/redis-server/7004/redis.conf &amp;/root/redis-server/7005/redis-server /root/redis-server/7005/redis.conf &amp;配置集群安装rubyyum install ruby-devel.x86_64安装redis gem# gem install redisFetching: redis-3.2.1.gem (100%)Successfully installed redis-3.2.1Parsing documentation for redis-3.2.1Installing ri documentation for redis-3.2.11 gem installed使用脚本建立集群机制在create的时候,加上参数–replicas 1 表示为每个master分配一个salve,如例子,则是3个master 3个salve# ./redis-trib.rb create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005&gt;&gt;&gt; Creating clusterConnecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7002: OKConnecting to node 127.0.0.1:7003: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7005: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes…Using 6 masters:127.0.0.1:7000127.0.0.1:7001127.0.0.1:7002127.0.0.1:7003127.0.0.1:7004127.0.0.1:7005M: f3dd250e4bc145c8b9f864e82f65e00d1ba627be 127.0.0.1:7000 slots:0-2730 (2731 slots) masterM: 1ba602ade59e0770a15128b193f2ac29c251ab5e 127.0.0.1:7001 slots:2731-5460 (2730 slots) masterM: 4f840a70520563c8ef0d7d1cc9d5eaff6a1547a2 127.0.0.1:7002 slots:5461-8191 (2731 slots) masterM: 702adc7ae9caf1f6702987604548c6fc1d22e813 127.0.0.1:7003 slots:8192-10922 (2731 slots) masterM: 4f87a11d2ea6ebe9caf02c9dbd827a3dba8a53cf 127.0.0.1:7004 slots:10923-13652 (2730 slots) masterM: 216bbb7da50bd130da16a327c76dc6d285f731b3 127.0.0.1:7005 slots:13653-16383 (2731 slots) masterCan I set the above configuration? (type ‘yes’ to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join…&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: f3dd250e4bc145c8b9f864e82f65e00d1ba627be 127.0.0.1:7000 slots:0-2730 (2731 slots) masterM: 1ba602ade59e0770a15128b193f2ac29c251ab5e 127.0.0.1:7001 slots:2731-5460 (2730 slots) masterM: 4f840a70520563c8ef0d7d1cc9d5eaff6a1547a2 127.0.0.1:7002 slots:5461-8191 (2731 slots) masterM: 702adc7ae9caf1f6702987604548c6fc1d22e813 127.0.0.1:7003 slots:8192-10922 (2731 slots) masterM: 4f87a11d2ea6ebe9caf02c9dbd827a3dba8a53cf 127.0.0.1:7004 slots:10923-13652 (2730 slots) masterM: 216bbb7da50bd130da16a327c76dc6d285f731b3 127.0.0.1:7005 slots:13653-16383 (2731 slots) master[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots…&gt;&gt;&gt; Check slots coverage…[OK] All 16384 slots covered.如果需要全部重新自动配置,则删除所有的配置好的cluster-config-file,重新启动所有的redis-server,然后重新执行配置命令即可","tags":[]},{"title":"rename","date":"2016-07-22T09:10:07.000Z","path":"2016/07/22/rename/","text":"Dos/Windows下，对文件改名用rename。而书上说，Linux下对文件或目录改名该用mv。我一直也是这样做的，却忽略了Linux下也有 个叫rename的命令。都是rename，但功能上就有点差异了。Linux下的rename更像批量改名的工具，是util-linux套件中提供 的。 一、基本功能从mv和rename命令的man文档中，可以看到如下信息： 引用mv - move (rename) filesrename - Rename files也就是说，mv也能用于改名，但不能实现批量处理（改名时，不支持等符号的），而rename可以。rename使用的格式：$ rename foo foo0 foo?rename需要提供三个参数，然后才能决定最终结果。模拟一下man文档的例子，原文件：引用$ for i in seq 100;do touch foo$i;done$ lsfoo1 foo18 foo27 foo36 foo45 foo54 foo63 foo72 foo81 foo90foo10 foo19 foo28 foo37 foo46 foo55 foo64 foo73 foo82 foo91foo100 foo2 foo29 foo38 foo47 foo56 foo65 foo74 foo83 foo92foo11 foo20 foo3 foo39 foo48 foo57 foo66 foo75 foo84 foo93foo12 foo21 foo30 foo4 foo49 foo58 foo67 foo76 foo85 foo94foo13 foo22 foo31 foo40 foo5 foo59 foo68 foo77 foo86 foo95foo14 foo23 foo32 foo41 foo50 foo6 foo69 foo78 foo87 foo96foo15 foo24 foo33 foo42 foo51 foo60 foo7 foo79 foo88 foo97foo16 foo25 foo34 foo43 foo52 foo61 foo70 foo8 foo89 foo98foo17 foo26 foo35 foo44 foo53 foo62 foo71 foo80 foo9 foo99改名结果：（红色是没有改动的，蓝色是有改动的一部分）引用$ rename foo foo0 foo?$ lsfoo01foo100foo20 foo30 foo40 foo50 foo60 foo70 foo80 foo90foo02 foo11 foo21 foo31 foo41 foo51 foo61 foo71 foo81 foo91foo03 foo12 foo22 foo32 foo42 foo52 foo62 foo72 foo82 foo92foo04 foo13 foo23 foo33 foo43 foo53 foo63 foo73 foo83 foo93foo05 foo14 foo24 foo34 foo44 foo54 foo64 foo74 foo84 foo94foo06 foo15 foo25 foo35 foo45 foo55 foo65 foo75 foo85 foo95foo07 foo16 foo26 foo36 foo46 foo56 foo66 foo76 foo86 foo96foo08 foo17 foo27 foo37 foo47 foo57 foo67 foo77 foo87 foo97foo09 foo18 foo28 foo38 foo48 foo58 foo68 foo78 foo88 foo98foo10 foo19 foo29 foo39 foo49 foo59 foo69 foo79 foo89 foo99$ rename foo foo0 foo??$ lsfoo001 foo011 foo021 foo031 foo041 foo051 foo061 foo071 foo081 foo091foo002 foo012 foo022 foo032 foo042 foo052 foo062 foo072 foo082 foo092foo003 foo013 foo023 foo033 foo043 foo053 foo063 foo073 foo083 foo093foo004 foo014 foo024 foo034 foo044 foo054 foo064 foo074 foo084 foo094foo005 foo015 foo025 foo035 foo045 foo055 foo065 foo075 foo085 foo095foo006 foo016 foo026 foo036 foo046 foo056 foo066 foo076 foo086 foo096foo007 foo017 foo027 foo037 foo047 foo057 foo067 foo077 foo087 foo097foo008 foo018 foo028 foo038 foo048 foo058 foo068 foo078 foo088 foo098foo009 foo019 foo029 foo039 foo049 foo059 foo069 foo079 foo089 foo099foo010 foo020 foo030 foo040 foo050 foo060 foo070 foo080 foo090 foo100该例子给出了两种文件批量重命名的用法：引用第一个参数：被替换掉的字符串第二个参数：替换成的字符串第三个参数：匹配要替换的文件模式rename支持通配符，基本的通配符有以下几个：引用? 可替代单个字符 可替代多个字符[charset] 可替代charset集中的任意单个字符二、其他例子看看的作用：引用$ rm -f $ for i in seq 100;do touch foo$i;done$ rename foo foo0 foo$ lsfoo01 foo018 foo027 foo036 foo045 foo054 foo063 foo072 foo081 foo090foo010 foo019 foo028 foo037 foo046 foo055 foo064 foo073 foo082 foo091foo0100 foo02 foo029 foo038 foo047 foo056 foo065 foo074 foo083 foo092foo011 foo020 foo03 foo039 foo048 foo057 foo066 foo075 foo084 foo093foo012 foo021 foo030 foo04 foo049 foo058 foo067 foo076 foo085 foo094foo013 foo022 foo031 foo040 foo05 foo059 foo068 foo077 foo086 foo095foo014 foo023 foo032 foo041 foo050 foo06 foo069 foo078 foo087 foo096foo015 foo024 foo033 foo042 foo051 foo060 foo07 foo079 foo088 foo097foo016 foo025 foo034 foo043 foo052 foo061 foo070 foo08 foo089 foo098foo017 foo026 foo035 foo044 foo053 foo062 foo071 foo080 foo09 foo099再看看[charset]的作用：引用$ rm -f $ for i in seq 100;do touch foo$i;done$ rename foo foo0 foo[9]*$ lsfoo09 foo099 foo17 foo26 foo35 foo44 foo53 foo62 foo71 foo80foo090 foo1 foo18 foo27 foo36 foo45 foo54 foo63 foo72 foo81foo091 foo10 foo19 foo28 foo37 foo46 foo55 foo64 foo73 foo82foo092 foo100 foo2 foo29 foo38 foo47 foo56 foo65 foo74 foo83foo093 foo11 foo20 foo3 foo39 foo48 foo57 foo66 foo75 foo84foo094 foo12 foo21 foo30 foo4 foo49 foo58 foo67 foo76 foo85foo095 foo13 foo22 foo31 foo40 foo5 foo59 foo68 foo77 foo86foo096 foo14 foo23 foo32 foo41 foo50 foo6 foo69 foo78 foo87foo097 foo15 foo24 foo33 foo42 foo51 foo60 foo7 foo79 foo88foo098 foo16 foo25 foo34 foo43 foo52 foo61 foo70 foo8 foo89","tags":[]},{"title":"世界，您好！","date":"2016-07-21T16:56:46.000Z","path":"2016/07/22/hello-world/","text":"欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！","tags":[]}]